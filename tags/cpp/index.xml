<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CPP on VcVc Blog</title>
    <link>https://6923403.github.io/tags/cpp/</link>
    <description>Recent content in CPP on VcVc Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 27 Aug 2020 12:09:01 +0800</lastBuildDate>
    
	<atom:link href="https://6923403.github.io/tags/cpp/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>epoll use</title>
      <link>https://6923403.github.io/post/epoll_use/</link>
      <pubDate>Thu, 27 Aug 2020 12:09:01 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/epoll_use/</guid>
      <description>#include &amp;lt;sys/epoll.h&amp;gt; epoll与select Epoll 没有最大并发连接的限制，上限是最大可以打开文件的数目 效率提升，epoll对于句柄事件的选择不是遍历的，是事件响应的，就是句柄上事件来就马上选择出来，不需要遍历整个句柄链表，因此效率非常高，内核将句柄用红黑树保存的，IO效率不随FD数目增加而线性下降。 内存拷贝， select让内核把 FD 消息通知给用户空间的时候使用了内存拷贝的方式，开销较大，但是Epoll 在这点上使用了共享内存的方式，这个内存拷贝也省略了。 相比于select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。因为在内核中的select实现中，它是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。 并且，在linux/posix_types.h头文件有这样的声明： #define __FD_SETSIZE 1024 表示select最多同时监听1024个fd，当然，可以通过修改头文件再重编译内核来扩大这个数目，但这似乎并不治本。
 epoll_create int epoll_create(int size); 创建一个epoll的句柄，
size用来告诉内核这个监听的数目一共有多大。 这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。
 epoll_ctl int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); epoll_ctl(_iEpollfd, op, fd, &amp;amp;ev); //Error:_iEpollfd: -1. Success: _iEpollfd = fd epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型
EPOLL_CTL_ADD 注册新的fd到epfd中； EPOLL_CTL_MOD 修改已经注册的fd的监听事件； EPOLL_CTL_DEL 从epfd中删除一个fd；
fd 是要监听的fd
event 是要监听什么样的事件
 typedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; struct epoll_event { uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ }; events可以是以下几个宏的集合:</description>
    </item>
    
    <item>
      <title>Socket function</title>
      <link>https://6923403.github.io/post/socket/</link>
      <pubDate>Wed, 26 Aug 2020 22:47:24 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/socket/</guid>
      <description>gethostbyname_r(sAddr.c_str(), &amp;amp;stHostent, buf, sizeof(buf), &amp;amp;pstHostent, &amp;amp;iError); //gethostbyname_r()调用成功时返回0, *result指向解析成功的数据结构, *result如果为NULL则表示解析出错
 int iRet = inet_pton(AF_INET, sAddr.c_str(), &amp;amp;stSinAddr); //地址类型转换
 setsockopt
获取或者设置与某个套接字关联的选 项。选项可能存在于多层协议中，它们总会出现在最上面的套接字层。当操作套接字选项时， 选项位于的层和选项的名称必须给出。为了操作套接字层的选项，应该 将层的值指定为SOL_SOCKET。为了操作其它层的选项，控制选 项的合适协议号必须给出。例如，为了表示一个选项由TCP协议解析，层应该设定为协议 号TCP。 Re: https://www.cnblogs.com/eeexu123/p/5275783.html
 epoll_ctl(_iEpollfd, op, fd, &amp;amp;ev); //Error:_iEpollfd: -1. Success: _iEpollfd = fd
 inet_ntoa()是编程语言，功能是将网络地址转换成“.”点隔的字符串格式。
 </description>
    </item>
    
    <item>
      <title>Makefile template</title>
      <link>https://6923403.github.io/post/makefile_template/</link>
      <pubDate>Wed, 19 Aug 2020 10:21:09 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/makefile_template/</guid>
      <description>V1  ############ 交叉编译 CROSS_COMPILE=aarch64-himix100-linux- CC=$(CROSS_COMPILE)g++ # 当前路径 PWD := $(shell pwd) #库 LIB += -lpthread -lsqlite3 #参数 CFLAG= -D_GNU_SOURCE -D__USE_XOPEN -g #.cpp源文件 SRCS=$(wildcard ./src/*.cpp) #头文件 INC=-I$(PWD)/include #中间文件 OBJS=$(SRCS:.cpp=.o) #二进制文件 BIN=maincpp #start，表示开始执行 start:$(OBJS) $(CC) -o $(BIN) $(OBJS) $(CFLAG) $(LIB) .cpp.o: $(CC) $(INC) -o $@ -c $&amp;lt; $(CFLAB) $(LIB) .PHONY : clean clean: rm -f ${BIN} ./src/*.o  V2 # Makefile cc=gcc LDFLAGS=-lncurses SRCS := $(wildcard *.c) TARGET := $(SRCS:%.c=%) $(TARGET):$(SRCS) $(cc) $(LDFLAGS) $(SRCS) -o $(TARGET) clean: rm $(TARGET)  Reference: Makefile 文件 -只有include和src文件夹</description>
    </item>
    
    <item>
      <title>Binary Tree</title>
      <link>https://6923403.github.io/post/binart_tree/</link>
      <pubDate>Tue, 18 Aug 2020 14:40:25 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/binart_tree/</guid>
      <description>性质1:在二叉树的第i层上至多有2 i-1 个结点(i≥1)。
  性质2:深度为k的二叉树至多有2 k -1个结点(k≥1)。
  性质3:对任何一棵二叉树T,如果其终端结点数为n 0 ,度为2的结点数 为n 2 ,则n 0 =n 2 +1。
  性质4:具有n个结点的完全二叉树的深度为|log 2 n+1|(|x|表示不大于x 的最大整数)。
  性质5:如果对一棵有n个结点的完全二叉树(其深度为)的结点按层序 编号(从第1层到第层,每层从左到右),对任一结点i(1≤i≤n)有:
   1.如果i=1,则结点i是二叉树的根,无双亲;如果i&amp;gt;1,则其双亲是结 点。
  2.如果2i&amp;gt;n,则结点i无左孩子(结点i为叶子结点);否则其左孩子是 结点2i。
  3.如果2i+1&amp;gt;n,则结点i无右孩子;否则其右孩子是结点2i+1。
  树转换为二叉树 将树转换为二叉树的步骤如下
  1.加线。在所有兄弟结点之间加一条连 线。
  2.去线。对树中每个结点,只保留它与第一个孩子结点的连线,删 除它与其他孩子结点之间的连线。
  3.层次调整。以树的根结点为轴心, 将整棵树顺时针旋转一定的角度,使之结构层次分明。注意第一个孩子 是二叉树结点的左孩子,兄弟转换过来的孩子是结点的右孩子
   森林转换为二叉树 森林是由若干棵树组成的,所以完全可以理解为,森林中的每一棵树都是兄弟,可以按照兄弟的处理办法来操作 .
 1.把每个树转换为二叉树。 2.第一棵二叉树不动,从第二棵二叉树开始,依次把后一棵 二叉树的根结点作为前一棵二叉树的根结点的右孩子,用线连接起来。 当所有的二叉树连接起来后就得到了由森林转换来的二叉树。   二叉树转换为树 二叉树转换为树是树转换为二叉树的逆过程,也就是反过来做而已。</description>
    </item>
    
    <item>
      <title>C&#43;&#43; auto ponit</title>
      <link>https://6923403.github.io/post/cpp_auto_ponit/</link>
      <pubDate>Mon, 17 Aug 2020 15:10:13 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/cpp_auto_ponit/</guid>
      <description>shared_ptr unique_ptr weak_ptr auto_ptr //drop in c++11  Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。 Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。   1.shared_ptr 多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。
 支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁   2.weak_ptr weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。
 可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题   3.unique_ptr unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。</description>
    </item>
    
    <item>
      <title>Constexpr</title>
      <link>https://6923403.github.io/post/constexpr/</link>
      <pubDate>Fri, 14 Aug 2020 16:16:33 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/constexpr/</guid>
      <description>0.Array int url[10]; //true int url[6 + 4] //true int len = 10; int url[len] //flase  1.Constexpr #include &amp;lt;iostream&amp;gt; using namespace std; int main() { /* * If have not constexpr, CPP throw error */ constexpr int num = 1 + 2 + 3; int url[num] = {1,2,3,4,5,6}; couts&amp;lt;&amp;lt; url[1] &amp;lt;&amp;lt; endl; return 0; }  2.Only have one &amp;lsquo;return&amp;rsquo; # Error constexpr int display(int x) { int ret = 1 + 2 + x; return ret; } # True constexpr int display(int x) { return 1 + 2 + x; }  3.</description>
    </item>
    
    <item>
      <title>GDB tutorial</title>
      <link>https://6923403.github.io/post/use_gdb/</link>
      <pubDate>Fri, 07 Aug 2020 16:45:20 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/use_gdb/</guid>
      <description>Start gdb or gdb -q # exit ctrl + d or quit  Use g++ -g main.cpp -o main gdb main -q or gdb -q file main Debug runing program
ps ux | grep showpng gdb showpng 28334 -q  CoreDump ** Check if off **
ulimit -c 0 # is off # tmp use ulimit -c unlimited ulimit -c unlimited # turn open permanent use
vim /etc/security/limits.conf # add line * soft core unlimited # and echo &amp;quot;core.</description>
    </item>
    
    <item>
      <title>Variable function(fun(char *, ...)) and vsnprintf()</title>
      <link>https://6923403.github.io/post/variable_function/</link>
      <pubDate>Tue, 28 Jul 2020 14:44:30 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/variable_function/</guid>
      <description>void fun(char * fmt, &amp;hellip;); int vsprintf(char *str, const char *format, va_list arg);
  Test programming #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdarg.h&amp;gt; /* * Re: https://github.com/antirez/kilo/kilo.c * Re: https://www.runoob.com/cprogramming/c-function-vsprintf.html */ char buffer[80]; int editorSetstatus(const char * fmt, ...) { va_list ap; va_start(ap, fmt); int ret; ret = vsnprintf(buffer, sizeof(buffer - 1), fmt, ap); va_end(ap); return (ret); } int main(int argc, char **argv) { int len = 20; editorSetstatus(&amp;quot;%d&amp;quot;, len); printf(&amp;quot;%s \n&amp;quot;, buffer); return 0; }  gcc -Wall -g fun.</description>
    </item>
    
    <item>
      <title>Linux install Boost c&#43;&#43;</title>
      <link>https://6923403.github.io/post/linux_install_boost/</link>
      <pubDate>Tue, 28 Jul 2020 13:09:01 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/linux_install_boost/</guid>
      <description>Boost C++ is Cpp programming language that provides support for tasks and structures
 Download Source https://dl.bintray.com/boostorg/release/1.73.0/source/boost_1_73_0.tar.gz tar zxvf boost(解压)  Set use GCC cd boost ./bootstrap.sh --with-libraries=all --with-toolset=gcc  Compile &amp;amp; Install boost ./b2 toolset=gcc ./b2 install --prefix=/usr  Test programming #include &amp;lt;boost/thread/thread.hpp&amp;gt; //boost thread #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; volatile bool isRuning = true; void func1() { static int cnt1 = 0; while(isRuning) { cout &amp;lt;&amp;lt; &amp;quot;func1:&amp;quot; &amp;lt;&amp;lt; cnt1++ &amp;lt;&amp;lt; endl; sleep(1); } } void func2() { static int cnt2 = 0; while(isRuning) { cout &amp;lt;&amp;lt; &amp;quot;\tfunc2:&amp;quot; &amp;lt;&amp;lt; cnt2++ &amp;lt;&amp;lt; endl; sleep(2); } } int main() { boost::thread thread1(&amp;amp;func1); boost::thread thread2(&amp;amp;func2); system(&amp;quot;read&amp;quot;); isRuning = false; thread2.</description>
    </item>
    
  </channel>
</rss>