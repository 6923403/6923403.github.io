<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on VcVc Blog</title>
    <link>https://6923403.github.io/tags/linux/</link>
    <description>Recent content in Linux on VcVc Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 27 Sep 2020 18:00:39 +0800</lastBuildDate>
    
	<atom:link href="https://6923403.github.io/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Socket sum</title>
      <link>https://6923403.github.io/post/socketsum/</link>
      <pubDate>Sun, 27 Sep 2020 18:00:39 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/socketsum/</guid>
      <description>socket struct整理
https://6923403.github.io/post/socket_struct/
 socket编程需要的头文件整理
https://6923403.github.io/post/socket_file/
 exception_class 异常类
https://6923403.github.io/post/cpp_exception/
 Linux Pthread 线程创建与使用
https://6923403.github.io/post/linuxpthread/
 epoll tutorial, epoll处理教程
https://6923403.github.io/post/epoll_use/
 socket function, socket函数
https://6923403.github.io/post/socket/</description>
    </item>
    
    <item>
      <title>Linux Pthread</title>
      <link>https://6923403.github.io/post/linuxpthread/</link>
      <pubDate>Sun, 27 Sep 2020 17:53:48 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/linuxpthread/</guid>
      <description>#include &amp;lt;pthread.h&amp;gt; int pthread_condattr_init(pthread_condattr_t* attr); int pthread_condattr_destroy(pthread_condattr_t* attr); //返回值：成功返回0；失败返回错误编码 pthread_condattr_init
 功能：对条件变量属性结构体初始化 调用此函数之后，条件变量属性结构体的属性都是系统默认值，如果想要设置其他属性，还需要调用不同的函数进行设置  pthread_condattr_destroy
 功能：对条件变量属性结构体反初始化（销毁） 只反初始化，不释放内存  Re:
https://blog.csdn.net/qq_41453285/article/details/90904870
 #include &amp;lt;pthread.h&amp;gt; int pthread_condattr_setshared(pthread_condattr_t* attr,int pshared); int pthread_condattr_getshared(const pthread_condattr_t* restrict attr,int* restrict pshared); //返回值：成功返回0；失败返回错误编码 pthread_condattr_setshared
 功能：设置条件变量的进程共享属性  pthread_condattr_getshared
 功能：获取条件变量的进程共享属性  Re:
https://blog.csdn.net/qq_41453285/article/details/90904870
 #include &amp;lt;pthread.h&amp;gt; int pthread_condattr_setclock(pthread_condattr_t* attr,clockid_t clock_id); int pthread_condattr_getclock(const pthread_condattr_t* restrict attr,clockid_t *restrict clock_id); //返回值：成功返回0；失败返回错误编码 pthread_condattr_setclock
 功能：此函数用于设置pthread_cond_timewait函数使用的时钟ID  pthread_condattr_getclock
 功能：此函数获取可被用于pthread_cond_timedwait函数的时钟ID。pthread_cond_timedwait函数使用前需要用pthread_condattr_t对条件变量进行初始化  Re:</description>
    </item>
    
    <item>
      <title>Mysql_use</title>
      <link>https://6923403.github.io/post/mysql_use/</link>
      <pubDate>Fri, 25 Sep 2020 16:40:02 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/mysql_use/</guid>
      <description>Mysql ex     mysql_init() 获取或初始化MYSQL结构   mysql_real_connect() 连接到MySQL服务器。   mysql_query() 执行指定为“以Null终结的字符串”的SQL查询   mysql_use_result() 初始化逐行的结果集检索   mysql_field_count() 返回上次执行语句的结果集的列数   mysql_fetch_row() 从结果集中获取下一行   mysql_num_fields() 返回结果集中的字段数     class MyDB { public: MyDB(); ~MyDB(); bool initDB(string host, string user, string pwd, string db_name); bool exeSQL(string sql); private: MYSQL *connection; MYSQL_RES *result; MYSQL_ROW row; };  基本步骤
使用mysql_init()初始化连接 使用mysql_real_connect()建立一个到mysql数据库的连接 使用mysql_query()执行查询语句 result = mysql_use_result(conn)获取结果集 mysql_field_count(conn)获取查询的列数，mysql_num_fields(result)获取结果集的字段数 通过mysql_fetch_row(result)不断获取下一行，然后循环输出 释放结果集所占内存mysql_free_result(result) mysql_close(conn)关闭连接  Re:</description>
    </item>
    
    <item>
      <title>Centos7 Install mongodb</title>
      <link>https://6923403.github.io/post/install_mongodb/</link>
      <pubDate>Mon, 21 Sep 2020 13:44:35 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/install_mongodb/</guid>
      <description>Configure the package management system (yum) vim /etc/yum.repos.d/mongodb-org-4.4.repo
[mongodb-org-4.4] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.4/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-4.4.asc  Install Mongodb sudo yum install -y mongodb-org  Directory Paths sudo mkdir -p /var/lib/mongo sudo mkdir -p /var/log/mongodb sudo chown -R mongod:mongod /var/lib/mongo sudo chown -R mongod:mongod /var/log/mongodb Start mongodb sudo systemctl start mongod sudo systemctl status mongod sudo systemctl enable mongod mongo //use  Re:
https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/</description>
    </item>
    
    <item>
      <title>Centos7 Install_redis</title>
      <link>https://6923403.github.io/post/install_redis/</link>
      <pubDate>Mon, 21 Sep 2020 13:32:22 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/install_redis/</guid>
      <description>升级GCC yum -y install centos-release-scl yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils scl enable devtoolset-9 bash echo &amp;quot;source /opt/rh/devtoolset-9/enable&amp;quot; &amp;gt;&amp;gt; /etc/profile gcc -v  安装redis wget http://download.redis.io/releases/redis-6.0.8.tar.gz tar -xvf redis-6.0.8/tar/gz cd redis make -j4 make install PREFIX=/usr/local/redis  配置redis cd redis cp redis.conf /usr/local/redis/bin/ vim /usr/local/redis/bin/redis.conf
daemonize no 改为 daemonize yes  开机自启 vim /etc/systemd/system/redis.service
[Unit] Description=redis-server After=network.target [Service] Type=forking ExecStart=/usr/local/redis/bin/redis-server /usr/local/redis/bin/redis.conf PrivateTmp=true [Install] WantedBy=multi-user.target systemctl daemon-reload ln -s /usr/local/redis/bin/redis-cli /usr/bin/redis systemctl start redis.</description>
    </item>
    
    <item>
      <title>Centos7 Install mysql</title>
      <link>https://6923403.github.io/post/install_mysql/</link>
      <pubDate>Sun, 20 Sep 2020 22:36:44 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/install_mysql/</guid>
      <description>1.添加Mysql5.7仓库 sudo rpm -ivh https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm
2.确认Mysql仓库成功添加 sudo yum repolist all | grep mysql | grep enabled
3.安装Mysql5.7 sudo yum -y install mysql-community-server
4.启动Mysql sudo systemctl start mysqld
5.设置系统启动时自动启动 sudo systemctl enable mysqld
6.查看启动状态 sudo systemctl status mysqld
7.root 密码 cat /var/log/mysqld.log | grep -i &#39;temporary password&#39;
8.执行下面命令进行安全设置 这个命令会进行设置root密码设置，移除匿名用户，禁止root用户远程连接等
mysql_secure_installation
9.设置数据库编码为utf8 sudo vim /etc/my.cnf
[client] default-character-set=utf8 [mysql] default-character-set=utf8 [mysqld] collation-server = utf8_unicode_ci init-connect=&#39;SET NAMES utf8&#39; character-set-server = utf8 reboot sudo systemctl restart mysqld</description>
    </item>
    
    <item>
      <title>getopt_long</title>
      <link>https://6923403.github.io/post/getopt_long/</link>
      <pubDate>Sun, 20 Sep 2020 14:26:33 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/getopt_long/</guid>
      <description>#include &amp;lt;unistd.h&amp;gt; int getopt(int argc, char * const argv[], const char *optstring); extern char *optarg; extern int optind, opterr, optopt; #include &amp;lt;getopt.h&amp;gt; int getopt_long(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex); int getopt_long_only(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex);  static struct option Vcopts[] = { {&amp;quot;device&amp;quot;, required_argument, NULL, &#39;d&#39;}, {&amp;quot;savefile&amp;quot;, optional_argument, NULL, &#39;f&#39;}, {&amp;quot;help&amp;quot;, no_argument, NULL, &#39;h&#39;}, {&amp;quot;version&amp;quot;, no_argument, NULL, &#39;v&#39;}, {&amp;quot;Device list&amp;quot;, no_argument, NULL, &#39;l&#39;}, {&amp;quot;http-proxy&amp;quot;, required_argument, &amp;amp;lopt, 1}, {0, 0, 0, 0} };  no_argument: -h --h, -v --v required_argument: -d/ -d ens33/ -d = ens33 optional_argument: -f filename/ -f = filename &amp;amp;lopt: &amp;ndash;http-proxy=127.</description>
    </item>
    
    <item>
      <title>Socket struct</title>
      <link>https://6923403.github.io/post/socket_struct/</link>
      <pubDate>Sun, 13 Sep 2020 17:03:43 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/socket_struct/</guid>
      <description>struct sockaddr { unsigned short sa_family; /* address family, AF_xxx */ char sa_data[14]; /* 14 bytes of protocol address */ }; 此数据结构用做bind、connect、recvfrom、sendto等函数的参数，指明地址信息。
 但一般编程中并不直接针对此数据结构操作，而是使用另一个与sockaddr等价的数据结构sockaddr_in（在netinet/in.h中定义）：
struct sockaddr_in { short int sin_family; /* Address family */ unsigned short int sin_port; /* Port number */ struct in_addr sin_addr; /* Internet address */ unsigned char sin_zero[8]; /* Same size as struct sockaddr */ }; 在编程中大多数是使用sockaddr_in这个结构来设置/获取地址信息
  sin_family指代协议族，在socket编程中只能是AF_INET
  sin_port存储端口号（使用网络字节顺序）
  sin_addr存储IP地址，使用in_addr这个数据结构</description>
    </item>
    
    <item>
      <title>Socket file</title>
      <link>https://6923403.github.io/post/socket_file/</link>
      <pubDate>Sun, 13 Sep 2020 16:43:04 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/socket_file/</guid>
      <description>socket编程中需要用到的头文件
  sys/types.h：数据类型定义
  sys/socket.h：提供socket函数及数据结构
  netinet/in.h：定义数据结构sockaddr_in
  arpa/inet.h：提供IP地址转换函数
  netdb.h：提供设置及获取域名的函数
  sys/ioctl.h：提供对I/O控制的函数
  sys/poll.h：提供socket等待测试机制的函数
   其他在网络程序中常见的头文件
  unistd.h：提供通用的文件、目录、程序及进程操作的函数
  errno.h：提供错误号errno的定义，用于错误处理
  fcntl.h：提供对文件控制的函数
  time.h：提供有关时间的函数
  crypt.h：提供使用DES加密算法的加密函数
  pwd.h：提供对/etc/passwd文件访问的函数
  shadow.h：提供对/etc/shadow文件访问的函数
  pthread.h：提供多线程操作的函数
  signal.h：提供对信号操作的函数
  sys/wait.h、sys/ipc.h、sys/shm.h：提供进程等待、进程间通讯（IPC）及共享内存的函数
   建议：在编写网络程序时，可以直接使用下面这段头文件代码
#include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;sys/socket.h&amp;gt; #include &amp;lt;netdb.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.</description>
    </item>
    
    <item>
      <title>Cpp exception class</title>
      <link>https://6923403.github.io/post/cpp_exception/</link>
      <pubDate>Sun, 13 Sep 2020 15:13:08 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/cpp_exception/</guid>
      <description>class exception{ public: exception () throw(); //构造函数 exception (const exception&amp;amp;) throw(); //拷贝构造函数 exception&amp;amp; operator= (const exception&amp;amp;) throw(); //运算符重载 virtual ~exception() throw(); //虚析构函数 virtual const char* what() const throw(); //虚函数 } what() 函数返回一个能识别异常的字符串，正如它的名字“what”一样，可以粗略地告诉你这是什么异常。
 exception 类的继承层次:  exception 类 直接派生类
   exceptopn explain     login_error logic error   runtime_error 运行时错误   bad_alloc 使用 new 或 new[] 分配内存失败时抛出的异常   bad_typeid 使用 typeid 操作一个 NULL 指针，而且该指针是带有虚函数的类，这时抛出 bad_typeid 异常   bad_cast 使用 dynamic_cast 转换失败时抛出的异常   ios_base::failure io 过程中出现的异常   bad_exception 这是个特殊的异常，如果函数的异常列表里声明了 bad_exception 异常，当函数内部抛出了异常列表中没有的异常时，如果调用的 unexpected() 函数中抛出了异常，不论什么类型，都会被替换为 bad_exception 类型     logic_error 的派生类</description>
    </item>
    
    <item>
      <title>Linux cpp put Backtrace</title>
      <link>https://6923403.github.io/post/backtrace/</link>
      <pubDate>Wed, 02 Sep 2020 14:10:18 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/backtrace/</guid>
      <description>获取Backtrace #include &amp;lt;execinfo.h&amp;gt; /* Store up to SIZE return address of the current program state in ARRAY and return the exact number of values stored. */ int backtrace(void **array, int size); /* Return names of functions from the backtrace list in ARRAY in a newly malloc()ed memory block. */ char **backtrace_symbols(void *const *array, int size); /* This function is similar to backtrace_symbols() but it writes the result immediately to a file.</description>
    </item>
    
    <item>
      <title>epoll use</title>
      <link>https://6923403.github.io/post/epoll_use/</link>
      <pubDate>Thu, 27 Aug 2020 12:09:01 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/epoll_use/</guid>
      <description>epoll是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。
epoll除了提供select/poll那种IO事件的水平触发（Level Triggered）外，还提供了边缘触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。
  水平触发（LT）：默认工作模式，即当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序可以不立即处理该事件；下次调用epoll_wait时，会再次通知此事件
  边缘触发（ET）： 当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次通知此事件。（直到你做了某些操作导致该描述符变成未就绪状态了，也就是说边缘触发只在状态由未就绪变为就绪时只通知一次）。
   #include &amp;lt;sys/epoll.h&amp;gt; epoll与select Epoll 没有最大并发连接的限制，上限是最大可以打开文件的数目 效率提升，epoll对于句柄事件的选择不是遍历的，是事件响应的，就是句柄上事件来就马上选择出来，不需要遍历整个句柄链表，因此效率非常高，内核将句柄用红黑树保存的，IO效率不随FD数目增加而线性下降。 内存拷贝， select让内核把 FD 消息通知给用户空间的时候使用了内存拷贝的方式，开销较大，但是Epoll 在这点上使用了共享内存的方式，这个内存拷贝也省略了。 相比于select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。因为在内核中的select实现中，它是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。 并且，在linux/posix_types.h头文件有这样的声明： #define __FD_SETSIZE 1024 表示select最多同时监听1024个fd，当然，可以通过修改头文件再重编译内核来扩大这个数目，但这似乎并不治本。
 epoll_create int epoll_create(int size); 创建一个epoll的句柄，
size用来告诉内核这个监听的数目一共有多大。 这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。
 epoll_ctl int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); epoll_ctl(_iEpollfd, op, fd, &amp;amp;ev); //Error:_iEpollfd: -1. Success: _iEpollfd = fd epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型
EPOLL_CTL_ADD 注册新的fd到epfd中； EPOLL_CTL_MOD 修改已经注册的fd的监听事件； EPOLL_CTL_DEL 从epfd中删除一个fd；
fd 是要监听的fd</description>
    </item>
    
    <item>
      <title>Socket function</title>
      <link>https://6923403.github.io/post/socket/</link>
      <pubDate>Wed, 26 Aug 2020 22:47:24 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/socket/</guid>
      <description>gethostbyname_r(sAddr.c_str(), &amp;amp;stHostent, buf, sizeof(buf), &amp;amp;pstHostent, &amp;amp;iError); //gethostbyname_r()调用成功时返回0, *result指向解析成功的数据结构, *result如果为NULL则表示解析出错
 int iRet = inet_pton(AF_INET, sAddr.c_str(), &amp;amp;stSinAddr); //地址类型转换
 setsockopt
获取或者设置与某个套接字关联的选 项。选项可能存在于多层协议中，它们总会出现在最上面的套接字层。当操作套接字选项时， 选项位于的层和选项的名称必须给出。为了操作套接字层的选项，应该 将层的值指定为SOL_SOCKET。为了操作其它层的选项，控制选 项的合适协议号必须给出。例如，为了表示一个选项由TCP协议解析，层应该设定为协议 号TCP。 Re: https://www.cnblogs.com/eeexu123/p/5275783.html
 epoll_ctl(_iEpollfd, op, fd, &amp;amp;ev); //Error:_iEpollfd: -1. Success: _iEpollfd = fd
 int fcntl(int fd, int cmd); int fcntl(int fd, int cmd, long arg); int fcntl(int fd, int cmd, struct flock *lock); fcntl函数有5种功能：
 1.复制一个现有的描述符（cmd=F_DUPFD）. 2.获得／设置文件描述符标记(cmd=F_GETFD或F_SETFD). 3.获得／设置文件状态标记(cmd=F_GETFL或F_SETFL). 4.获得／设置异步I/O所有权(cmd=F_GETOWN或F_SETOWN). 5.获得／设置记录锁(cmd=F_GETLK,F_SETLK或F_SETLKW).  Re: https://www.cnblogs.com/xuyh/p/3273082.html
 非阻塞I/O使我们的操作要么成功，要么立即返回错误，不被阻塞。</description>
    </item>
    
    <item>
      <title>Docker use Tutorial</title>
      <link>https://6923403.github.io/post/docker_tutorial/</link>
      <pubDate>Sat, 22 Aug 2020 16:42:04 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/docker_tutorial/</guid>
      <description>Install docker apt-get remove docker docker-engine docker.io containerd runc curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - apt-key fingerprint 0EBF**** add-apt-repository \ &amp;quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \ bionic \ stable&amp;quot; apt-get install docker-ce docker-ce-cli containerd.io # https://www.daocloud.io/mirror curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io docker run hello-world  Compose https://gitee.com/xipushi/dockercompose.git chmod +x docker-compose-Linux-x86_64 mv docker-compose-Linux-x86_64 docker-compose cp /use/local/bin docker-compose --version  Dockerfile # from based nginx # run start FROM nginx # exec: RUN[&amp;quot;.</description>
    </item>
    
    <item>
      <title>Makefile template</title>
      <link>https://6923403.github.io/post/makefile_template/</link>
      <pubDate>Wed, 19 Aug 2020 10:21:09 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/makefile_template/</guid>
      <description>V1  ############ 交叉编译 CROSS_COMPILE=aarch64-himix100-linux- CC=$(CROSS_COMPILE)g++ # 当前路径 PWD := $(shell pwd) #库 LIB += -lpthread -lsqlite3 #参数 CFLAG= -D_GNU_SOURCE -D__USE_XOPEN -g #.cpp源文件 SRCS=$(wildcard ./src/*.cpp) #头文件 INC=-I$(PWD)/include #中间文件 OBJS=$(SRCS:.cpp=.o) #二进制文件 BIN=maincpp #start，表示开始执行 start:$(OBJS) $(CC) -o $(BIN) $(OBJS) $(CFLAG) $(LIB) .cpp.o: $(CC) $(INC) -o $@ -c $&amp;lt; $(CFLAB) $(LIB) .PHONY : clean clean: rm -f ${BIN} ./src/*.o  V2 # Makefile cc=gcc LDFLAGS=-lncurses SRCS := $(wildcard *.c) TARGET := $(SRCS:%.c=%) $(TARGET):$(SRCS) $(cc) $(LDFLAGS) $(SRCS) -o $(TARGET) clean: rm $(TARGET)  Reference: Makefile 文件 -只有include和src文件夹</description>
    </item>
    
    <item>
      <title>GDB tutorial</title>
      <link>https://6923403.github.io/post/use_gdb/</link>
      <pubDate>Fri, 07 Aug 2020 16:45:20 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/use_gdb/</guid>
      <description>Start gdb or gdb -q # exit ctrl + d or quit  Use g++ -g main.cpp -o main gdb main -q or gdb -q file main Debug runing program
ps ux | grep showpng gdb showpng 28334 -q  CoreDump ** Check if off **
ulimit -c 0 # is off # tmp use ulimit -c unlimited ulimit -c unlimited # turn open permanent use
vim /etc/security/limits.conf # add line * soft core unlimited # and echo &amp;quot;core.</description>
    </item>
    
    <item>
      <title>Shell_command($!, $@...)</title>
      <link>https://6923403.github.io/post/shell_commans/</link>
      <pubDate>Sat, 01 Aug 2020 21:31:50 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/shell_commans/</guid>
      <description>./start.sh 1 2 3 4 num: $# = 4 PID: $$ = 24133 sname: $0 = start.sh first: $1 = 1 secont: $2 = 2 $@ = 1234 #value list $* = 1234 #value   $* 1 2 3 4  </description>
    </item>
    
    <item>
      <title>Arch Beautify desktop</title>
      <link>https://6923403.github.io/post/arch_desktop/</link>
      <pubDate>Thu, 30 Jul 2020 18:04:47 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/arch_desktop/</guid>
      <description>updat&amp;hellip;
1. install xorg pacman -S xorg-server xorg-xinit 2. install zsh, feh, i3gapsr, compton, oh-my-zsh pacman -S zsh xfce4-terminal feh compton i3-gaps nautilus i3lock sh -c &amp;quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&amp;quot;  install ttf pacman -S ttf-liberation pacman -S adobe-source-han-sans-cn-fonts pacman -S adobe-source-han-sans-tw-fonts pacman -S adobe-source-han-sans-jp-fonts  add user useradd -m -g users -s /bin/zsh xxxx #添加xxxx用户，用户名你自定义 passwd xxxx #为xxxx用户设置密码 vim /etc/sudoers #编辑配置文件 在root ALL = (ALL) ALL下添加xxxx ALL = (ALL) ALL;输入:wq!强制保存退出vim  startx exit login new user touch .</description>
    </item>
    
    <item>
      <title>Vmware install Archlinux </title>
      <link>https://6923403.github.io/post/arch_install/</link>
      <pubDate>Thu, 30 Jul 2020 16:43:47 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/arch_install/</guid>
      <description>0. Ready work Test environment: Vmware15.5.6pro arch-2020-07.iso You should installed Vmware and download Archlinux iso .
Change your firmwaretype to UEFI (The way many tutorials did not say)  1. Start ls /sys/firmware/efi/efivars The command detect UEFI files and if your dir not include files your firmwaretype is BIOS .
Then, ping google.com, detect interent connection
 Archwiki: Note: The installation image has systemd-networkd.service, systemd-resolved.service and iwd.service enabled by default. That will not be the case for the installed system.</description>
    </item>
    
    <item>
      <title>Ubuntu20 Install Nvidia drivers</title>
      <link>https://6923403.github.io/post/install_nvidia/</link>
      <pubDate>Wed, 29 Jul 2020 17:29:52 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/install_nvidia/</guid>
      <description>0.Ready work Disable BIOS secure boot，choose disable .
 1. Uninstall old Nvidia drivers sudo apt-get remove --purge nvidia*  2. Add rules vim /etc/modprobe.d/blacklist.conf
1. blacklist nouveau 2. options nouveau modeset=0  3. Verification After reboot, use the following command no return is successful
sudo update-initramfs -u lsmod | grep nouveau  4. Choose Navidia drivers version  1.Use command: ubuntu-drivers devices 2.Nvidia Official website  Choose stable version and install</description>
    </item>
    
    <item>
      <title>Linux install Boost c&#43;&#43;</title>
      <link>https://6923403.github.io/post/linux_install_boost/</link>
      <pubDate>Tue, 28 Jul 2020 13:09:01 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/linux_install_boost/</guid>
      <description>Boost C++ is Cpp programming language that provides support for tasks and structures
 Download Source https://dl.bintray.com/boostorg/release/1.73.0/source/boost_1_73_0.tar.gz tar zxvf boost(解压)  Set use GCC cd boost ./bootstrap.sh --with-libraries=all --with-toolset=gcc  Compile &amp;amp; Install boost ./b2 toolset=gcc ./b2 install --prefix=/usr  Test programming #include &amp;lt;boost/thread/thread.hpp&amp;gt; //boost thread #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; volatile bool isRuning = true; void func1() { static int cnt1 = 0; while(isRuning) { cout &amp;lt;&amp;lt; &amp;quot;func1:&amp;quot; &amp;lt;&amp;lt; cnt1++ &amp;lt;&amp;lt; endl; sleep(1); } } void func2() { static int cnt2 = 0; while(isRuning) { cout &amp;lt;&amp;lt; &amp;quot;\tfunc2:&amp;quot; &amp;lt;&amp;lt; cnt2++ &amp;lt;&amp;lt; endl; sleep(2); } } int main() { boost::thread thread1(&amp;amp;func1); boost::thread thread2(&amp;amp;func2); system(&amp;quot;read&amp;quot;); isRuning = false; thread2.</description>
    </item>
    
    <item>
      <title>Ubuntu20 install FFmpeg</title>
      <link>https://6923403.github.io/post/ffmpeg_install/</link>
      <pubDate>Mon, 27 Jul 2020 17:41:31 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/ffmpeg_install/</guid>
      <description>Start Download FFmpeg  Install tool 1. install yasm
sudo apt-get install yasm  if not installed yasm, os will output &amp;ldquo;nasm/yasm not found or too old. Use &amp;ndash;disable-x86asm for a crippled build.&amp;rdquo;
 2. install SDL2
SDL2-2.0.12(stable)
tar -xvf SDL2-2.0.12.tar.gz cd SDL2-2.0.12 ./configure sudo make -j4 sudo make install  Install FFmpeg 1. git clone https://git.ffmpeg.org/ffmpeg.git ffmpeg
cd ffmpeg/ ./configure sudo make -j4 sudo make install  3. Check ffmpeg -version ffplay -version </description>
    </item>
    
  </channel>
</rss>