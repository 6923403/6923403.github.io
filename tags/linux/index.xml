<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on VcVc Blog</title>
    <link>https://6923403.github.io/tags/linux/</link>
    <description>Recent content in Linux on VcVc Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 27 Aug 2020 12:09:01 +0800</lastBuildDate>
    
	<atom:link href="https://6923403.github.io/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>epoll use</title>
      <link>https://6923403.github.io/post/epoll_use/</link>
      <pubDate>Thu, 27 Aug 2020 12:09:01 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/epoll_use/</guid>
      <description>#include &amp;lt;sys/epoll.h&amp;gt; epoll与select Epoll 没有最大并发连接的限制，上限是最大可以打开文件的数目 效率提升，epoll对于句柄事件的选择不是遍历的，是事件响应的，就是句柄上事件来就马上选择出来，不需要遍历整个句柄链表，因此效率非常高，内核将句柄用红黑树保存的，IO效率不随FD数目增加而线性下降。 内存拷贝， select让内核把 FD 消息通知给用户空间的时候使用了内存拷贝的方式，开销较大，但是Epoll 在这点上使用了共享内存的方式，这个内存拷贝也省略了。 相比于select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。因为在内核中的select实现中，它是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。 并且，在linux/posix_types.h头文件有这样的声明： #define __FD_SETSIZE 1024 表示select最多同时监听1024个fd，当然，可以通过修改头文件再重编译内核来扩大这个数目，但这似乎并不治本。
 epoll_create int epoll_create(int size); 创建一个epoll的句柄，
size用来告诉内核这个监听的数目一共有多大。 这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。
 epoll_ctl int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); epoll_ctl(_iEpollfd, op, fd, &amp;amp;ev); //Error:_iEpollfd: -1. Success: _iEpollfd = fd epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型
EPOLL_CTL_ADD 注册新的fd到epfd中； EPOLL_CTL_MOD 修改已经注册的fd的监听事件； EPOLL_CTL_DEL 从epfd中删除一个fd；
fd 是要监听的fd
event 是要监听什么样的事件
 typedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; struct epoll_event { uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ }; events可以是以下几个宏的集合:</description>
    </item>
    
    <item>
      <title>Socket function</title>
      <link>https://6923403.github.io/post/socket/</link>
      <pubDate>Wed, 26 Aug 2020 22:47:24 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/socket/</guid>
      <description>gethostbyname_r(sAddr.c_str(), &amp;amp;stHostent, buf, sizeof(buf), &amp;amp;pstHostent, &amp;amp;iError); //gethostbyname_r()调用成功时返回0, *result指向解析成功的数据结构, *result如果为NULL则表示解析出错
 int iRet = inet_pton(AF_INET, sAddr.c_str(), &amp;amp;stSinAddr); //地址类型转换
 setsockopt
获取或者设置与某个套接字关联的选 项。选项可能存在于多层协议中，它们总会出现在最上面的套接字层。当操作套接字选项时， 选项位于的层和选项的名称必须给出。为了操作套接字层的选项，应该 将层的值指定为SOL_SOCKET。为了操作其它层的选项，控制选 项的合适协议号必须给出。例如，为了表示一个选项由TCP协议解析，层应该设定为协议 号TCP。 Re: https://www.cnblogs.com/eeexu123/p/5275783.html
 epoll_ctl(_iEpollfd, op, fd, &amp;amp;ev); //Error:_iEpollfd: -1. Success: _iEpollfd = fd
 inet_ntoa()是编程语言，功能是将网络地址转换成“.”点隔的字符串格式。
 </description>
    </item>
    
    <item>
      <title>Docker use Tutorial</title>
      <link>https://6923403.github.io/post/docker_tutorial/</link>
      <pubDate>Sat, 22 Aug 2020 16:42:04 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/docker_tutorial/</guid>
      <description>Install docker apt-get remove docker docker-engine docker.io containerd runc curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - apt-key fingerprint 0EBF**** add-apt-repository \ &amp;quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \ bionic \ stable&amp;quot; apt-get install docker-ce docker-ce-cli containerd.io # https://www.daocloud.io/mirror curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io docker run hello-world  Compose https://gitee.com/xipushi/dockercompose.git chmod +x docker-compose-Linux-x86_64 mv docker-compose-Linux-x86_64 docker-compose cp /use/local/bin docker-compose --version  Dockerfile # from based nginx # run start FROM nginx # exec: RUN[&amp;quot;.</description>
    </item>
    
    <item>
      <title>Makefile template</title>
      <link>https://6923403.github.io/post/makefile_template/</link>
      <pubDate>Wed, 19 Aug 2020 10:21:09 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/makefile_template/</guid>
      <description>V1  ############ 交叉编译 CROSS_COMPILE=aarch64-himix100-linux- CC=$(CROSS_COMPILE)g++ # 当前路径 PWD := $(shell pwd) #库 LIB += -lpthread -lsqlite3 #参数 CFLAG= -D_GNU_SOURCE -D__USE_XOPEN -g #.cpp源文件 SRCS=$(wildcard ./src/*.cpp) #头文件 INC=-I$(PWD)/include #中间文件 OBJS=$(SRCS:.cpp=.o) #二进制文件 BIN=maincpp #start，表示开始执行 start:$(OBJS) $(CC) -o $(BIN) $(OBJS) $(CFLAG) $(LIB) .cpp.o: $(CC) $(INC) -o $@ -c $&amp;lt; $(CFLAB) $(LIB) .PHONY : clean clean: rm -f ${BIN} ./src/*.o  V2 # Makefile cc=gcc LDFLAGS=-lncurses SRCS := $(wildcard *.c) TARGET := $(SRCS:%.c=%) $(TARGET):$(SRCS) $(cc) $(LDFLAGS) $(SRCS) -o $(TARGET) clean: rm $(TARGET)  Reference: Makefile 文件 -只有include和src文件夹</description>
    </item>
    
    <item>
      <title>GDB tutorial</title>
      <link>https://6923403.github.io/post/use_gdb/</link>
      <pubDate>Fri, 07 Aug 2020 16:45:20 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/use_gdb/</guid>
      <description>Start gdb or gdb -q # exit ctrl + d or quit  Use g++ -g main.cpp -o main gdb main -q or gdb -q file main Debug runing program
ps ux | grep showpng gdb showpng 28334 -q  CoreDump ** Check if off **
ulimit -c 0 # is off # tmp use ulimit -c unlimited ulimit -c unlimited # turn open permanent use
vim /etc/security/limits.conf # add line * soft core unlimited # and echo &amp;quot;core.</description>
    </item>
    
    <item>
      <title>Shell_command($!, $@...)</title>
      <link>https://6923403.github.io/post/shell_commans/</link>
      <pubDate>Sat, 01 Aug 2020 21:31:50 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/shell_commans/</guid>
      <description>./start.sh 1 2 3 4 num: $# = 4 PID: $$ = 24133 sname: $0 = start.sh first: $1 = 1 secont: $2 = 2 $@ = 1234 #value list $* = 1234 #value   $* 1 2 3 4  </description>
    </item>
    
    <item>
      <title>Arch Beautify desktop</title>
      <link>https://6923403.github.io/post/arch_desktop/</link>
      <pubDate>Thu, 30 Jul 2020 18:04:47 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/arch_desktop/</guid>
      <description>updat&amp;hellip;
1. install xorg pacman -S xorg-server xorg-xinit 2. install zsh, feh, i3gapsr, compton, oh-my-zsh pacman -S zsh xfce4-terminal feh compton i3-gaps nautilus i3lock sh -c &amp;quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&amp;quot;  install ttf pacman -S ttf-liberation pacman -S adobe-source-han-sans-cn-fonts pacman -S adobe-source-han-sans-tw-fonts pacman -S adobe-source-han-sans-jp-fonts  add user useradd -m -g users -s /bin/zsh xxxx #添加xxxx用户，用户名你自定义 passwd xxxx #为xxxx用户设置密码 vim /etc/sudoers #编辑配置文件 在root ALL = (ALL) ALL下添加xxxx ALL = (ALL) ALL;输入:wq!强制保存退出vim  startx exit login new user touch .</description>
    </item>
    
    <item>
      <title>Vmware install Archlinux </title>
      <link>https://6923403.github.io/post/arch_install/</link>
      <pubDate>Thu, 30 Jul 2020 16:43:47 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/arch_install/</guid>
      <description>0. Ready work Test environment: Vmware15.5.6pro arch-2020-07.iso You should installed Vmware and download Archlinux iso .
Change your firmwaretype to UEFI (The way many tutorials did not say)  1. Start ls /sys/firmware/efi/efivars The command detect UEFI files and if your dir not include files your firmwaretype is BIOS .
Then, ping google.com, detect interent connection
 Archwiki: Note: The installation image has systemd-networkd.service, systemd-resolved.service and iwd.service enabled by default. That will not be the case for the installed system.</description>
    </item>
    
    <item>
      <title>Ubuntu20 Install Nvidia drivers</title>
      <link>https://6923403.github.io/post/install_nvidia/</link>
      <pubDate>Wed, 29 Jul 2020 17:29:52 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/install_nvidia/</guid>
      <description>0.Ready work Disable BIOS secure boot，choose disable .
 1. Uninstall old Nvidia drivers sudo apt-get remove --purge nvidia*  2. Add rules vim /etc/modprobe.d/blacklist.conf
1. blacklist nouveau 2. options nouveau modeset=0  3. Verification After reboot, use the following command no return is successful
sudo update-initramfs -u lsmod | grep nouveau  4. Choose Navidia drivers version  1.Use command: ubuntu-drivers devices 2.Nvidia Official website  Choose stable version and install</description>
    </item>
    
    <item>
      <title>Linux install Boost c&#43;&#43;</title>
      <link>https://6923403.github.io/post/linux_install_boost/</link>
      <pubDate>Tue, 28 Jul 2020 13:09:01 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/linux_install_boost/</guid>
      <description>Boost C++ is Cpp programming language that provides support for tasks and structures
 Download Source https://dl.bintray.com/boostorg/release/1.73.0/source/boost_1_73_0.tar.gz tar zxvf boost(解压)  Set use GCC cd boost ./bootstrap.sh --with-libraries=all --with-toolset=gcc  Compile &amp;amp; Install boost ./b2 toolset=gcc ./b2 install --prefix=/usr  Test programming #include &amp;lt;boost/thread/thread.hpp&amp;gt; //boost thread #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; volatile bool isRuning = true; void func1() { static int cnt1 = 0; while(isRuning) { cout &amp;lt;&amp;lt; &amp;quot;func1:&amp;quot; &amp;lt;&amp;lt; cnt1++ &amp;lt;&amp;lt; endl; sleep(1); } } void func2() { static int cnt2 = 0; while(isRuning) { cout &amp;lt;&amp;lt; &amp;quot;\tfunc2:&amp;quot; &amp;lt;&amp;lt; cnt2++ &amp;lt;&amp;lt; endl; sleep(2); } } int main() { boost::thread thread1(&amp;amp;func1); boost::thread thread2(&amp;amp;func2); system(&amp;quot;read&amp;quot;); isRuning = false; thread2.</description>
    </item>
    
    <item>
      <title>Ubuntu20 install FFmpeg</title>
      <link>https://6923403.github.io/post/ffmpeg_install/</link>
      <pubDate>Mon, 27 Jul 2020 17:41:31 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/ffmpeg_install/</guid>
      <description>Start Download FFmpeg  Install tool 1. install yasm
sudo apt-get install yasm  if not installed yasm, os will output &amp;ldquo;nasm/yasm not found or too old. Use &amp;ndash;disable-x86asm for a crippled build.&amp;rdquo;
 2. install SDL2
SDL2-2.0.12(stable)
tar -xvf SDL2-2.0.12.tar.gz cd SDL2-2.0.12 ./configure sudo make -j4 sudo make install  Install FFmpeg 1. git clone https://git.ffmpeg.org/ffmpeg.git ffmpeg
cd ffmpeg/ ./configure sudo make -j4 sudo make install  3. Check ffmpeg -version ffplay -version </description>
    </item>
    
  </channel>
</rss>