<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on VcVc Blog</title>
    <link>https://6923403.github.io/tags/linux/</link>
    <description>Recent content in Linux on VcVc Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 17 Sep 2020 18:00:39 +0800</lastBuildDate>
    
	<atom:link href="https://6923403.github.io/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Socket sum</title>
      <link>https://6923403.github.io/post/socketsum/</link>
      <pubDate>Thu, 17 Sep 2020 18:00:39 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/socketsum/</guid>
      <description>socket struct整理
https://6923403.github.io/post/socket_struct/
 socket编程需要的头文件整理
https://6923403.github.io/post/socket_file/
 exception_class 异常类
https://6923403.github.io/post/cpp_exception/
 create thread 线程创建与使用
https://6923403.github.io/post/cppthread/
 epoll tutorial, epoll处理教程
https://6923403.github.io/post/epoll_use/
 socket function, socket函数
https://6923403.github.io/post/socket/</description>
    </item>
    
    <item>
      <title>Socket struct</title>
      <link>https://6923403.github.io/post/socket_struct/</link>
      <pubDate>Sun, 13 Sep 2020 17:03:43 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/socket_struct/</guid>
      <description>struct sockaddr { unsigned short sa_family; /* address family, AF_xxx */ char sa_data[14]; /* 14 bytes of protocol address */ }; 此数据结构用做bind、connect、recvfrom、sendto等函数的参数，指明地址信息。
 但一般编程中并不直接针对此数据结构操作，而是使用另一个与sockaddr等价的数据结构sockaddr_in（在netinet/in.h中定义）：
struct sockaddr_in { short int sin_family; /* Address family */ unsigned short int sin_port; /* Port number */ struct in_addr sin_addr; /* Internet address */ unsigned char sin_zero[8]; /* Same size as struct sockaddr */ }; 在编程中大多数是使用sockaddr_in这个结构来设置/获取地址信息
  sin_family指代协议族，在socket编程中只能是AF_INET
  sin_port存储端口号（使用网络字节顺序）
  sin_addr存储IP地址，使用in_addr这个数据结构</description>
    </item>
    
    <item>
      <title>Socket file</title>
      <link>https://6923403.github.io/post/socket_file/</link>
      <pubDate>Sun, 13 Sep 2020 16:43:04 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/socket_file/</guid>
      <description>socket编程中需要用到的头文件
  sys/types.h：数据类型定义
  sys/socket.h：提供socket函数及数据结构
  netinet/in.h：定义数据结构sockaddr_in
  arpa/inet.h：提供IP地址转换函数
  netdb.h：提供设置及获取域名的函数
  sys/ioctl.h：提供对I/O控制的函数
  sys/poll.h：提供socket等待测试机制的函数
   其他在网络程序中常见的头文件
  unistd.h：提供通用的文件、目录、程序及进程操作的函数
  errno.h：提供错误号errno的定义，用于错误处理
  fcntl.h：提供对文件控制的函数
  time.h：提供有关时间的函数
  crypt.h：提供使用DES加密算法的加密函数
  pwd.h：提供对/etc/passwd文件访问的函数
  shadow.h：提供对/etc/shadow文件访问的函数
  pthread.h：提供多线程操作的函数
  signal.h：提供对信号操作的函数
  sys/wait.h、sys/ipc.h、sys/shm.h：提供进程等待、进程间通讯（IPC）及共享内存的函数
   建议：在编写网络程序时，可以直接使用下面这段头文件代码
#include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;sys/socket.h&amp;gt; #include &amp;lt;netdb.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.</description>
    </item>
    
    <item>
      <title>Cpp exception class</title>
      <link>https://6923403.github.io/post/cpp_exception/</link>
      <pubDate>Sun, 13 Sep 2020 15:13:08 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/cpp_exception/</guid>
      <description>class exception{ public: exception () throw(); //构造函数 exception (const exception&amp;amp;) throw(); //拷贝构造函数 exception&amp;amp; operator= (const exception&amp;amp;) throw(); //运算符重载 virtual ~exception() throw(); //虚析构函数 virtual const char* what() const throw(); //虚函数 } what() 函数返回一个能识别异常的字符串，正如它的名字“what”一样，可以粗略地告诉你这是什么异常。
 exception 类的继承层次:  exception 类 直接派生类
   exceptopn explain     login_error logic error   runtime_error 运行时错误   bad_alloc 使用 new 或 new[] 分配内存失败时抛出的异常   bad_typeid 使用 typeid 操作一个 NULL 指针，而且该指针是带有虚函数的类，这时抛出 bad_typeid 异常   bad_cast 使用 dynamic_cast 转换失败时抛出的异常   ios_base::failure io 过程中出现的异常   bad_exception 这是个特殊的异常，如果函数的异常列表里声明了 bad_exception 异常，当函数内部抛出了异常列表中没有的异常时，如果调用的 unexpected() 函数中抛出了异常，不论什么类型，都会被替换为 bad_exception 类型     logic_error 的派生类</description>
    </item>
    
    <item>
      <title>Linux cpp put Backtrace</title>
      <link>https://6923403.github.io/post/backtrace/</link>
      <pubDate>Wed, 02 Sep 2020 14:10:18 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/backtrace/</guid>
      <description>获取Backtrace #include &amp;lt;execinfo.h&amp;gt; /* Store up to SIZE return address of the current program state in ARRAY and return the exact number of values stored. */ int backtrace(void **array, int size); /* Return names of functions from the backtrace list in ARRAY in a newly malloc()ed memory block. */ char **backtrace_symbols(void *const *array, int size); /* This function is similar to backtrace_symbols() but it writes the result immediately to a file.</description>
    </item>
    
    <item>
      <title>epoll use</title>
      <link>https://6923403.github.io/post/epoll_use/</link>
      <pubDate>Thu, 27 Aug 2020 12:09:01 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/epoll_use/</guid>
      <description>#include &amp;lt;sys/epoll.h&amp;gt; epoll与select Epoll 没有最大并发连接的限制，上限是最大可以打开文件的数目 效率提升，epoll对于句柄事件的选择不是遍历的，是事件响应的，就是句柄上事件来就马上选择出来，不需要遍历整个句柄链表，因此效率非常高，内核将句柄用红黑树保存的，IO效率不随FD数目增加而线性下降。 内存拷贝， select让内核把 FD 消息通知给用户空间的时候使用了内存拷贝的方式，开销较大，但是Epoll 在这点上使用了共享内存的方式，这个内存拷贝也省略了。 相比于select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。因为在内核中的select实现中，它是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。 并且，在linux/posix_types.h头文件有这样的声明： #define __FD_SETSIZE 1024 表示select最多同时监听1024个fd，当然，可以通过修改头文件再重编译内核来扩大这个数目，但这似乎并不治本。
 epoll_create int epoll_create(int size); 创建一个epoll的句柄，
size用来告诉内核这个监听的数目一共有多大。 这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。
 epoll_ctl int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); epoll_ctl(_iEpollfd, op, fd, &amp;amp;ev); //Error:_iEpollfd: -1. Success: _iEpollfd = fd epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型
EPOLL_CTL_ADD 注册新的fd到epfd中； EPOLL_CTL_MOD 修改已经注册的fd的监听事件； EPOLL_CTL_DEL 从epfd中删除一个fd；
fd 是要监听的fd
event 是要监听什么样的事件
 typedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; struct epoll_event { uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ }; events可以是以下几个宏的集合:</description>
    </item>
    
    <item>
      <title>Socket function</title>
      <link>https://6923403.github.io/post/socket/</link>
      <pubDate>Wed, 26 Aug 2020 22:47:24 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/socket/</guid>
      <description>gethostbyname_r(sAddr.c_str(), &amp;amp;stHostent, buf, sizeof(buf), &amp;amp;pstHostent, &amp;amp;iError); //gethostbyname_r()调用成功时返回0, *result指向解析成功的数据结构, *result如果为NULL则表示解析出错
 int iRet = inet_pton(AF_INET, sAddr.c_str(), &amp;amp;stSinAddr); //地址类型转换
 setsockopt
获取或者设置与某个套接字关联的选 项。选项可能存在于多层协议中，它们总会出现在最上面的套接字层。当操作套接字选项时， 选项位于的层和选项的名称必须给出。为了操作套接字层的选项，应该 将层的值指定为SOL_SOCKET。为了操作其它层的选项，控制选 项的合适协议号必须给出。例如，为了表示一个选项由TCP协议解析，层应该设定为协议 号TCP。 Re: https://www.cnblogs.com/eeexu123/p/5275783.html
 epoll_ctl(_iEpollfd, op, fd, &amp;amp;ev); //Error:_iEpollfd: -1. Success: _iEpollfd = fd
 int fcntl(int fd, int cmd); int fcntl(int fd, int cmd, long arg); int fcntl(int fd, int cmd, struct flock *lock); fcntl函数有5种功能：
 1.复制一个现有的描述符（cmd=F_DUPFD）. 2.获得／设置文件描述符标记(cmd=F_GETFD或F_SETFD). 3.获得／设置文件状态标记(cmd=F_GETFL或F_SETFL). 4.获得／设置异步I/O所有权(cmd=F_GETOWN或F_SETOWN). 5.获得／设置记录锁(cmd=F_GETLK,F_SETLK或F_SETLKW).  Re: https://www.cnblogs.com/xuyh/p/3273082.html
 非阻塞I/O使我们的操作要么成功，要么立即返回错误，不被阻塞。</description>
    </item>
    
    <item>
      <title>Docker use Tutorial</title>
      <link>https://6923403.github.io/post/docker_tutorial/</link>
      <pubDate>Sat, 22 Aug 2020 16:42:04 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/docker_tutorial/</guid>
      <description>Install docker apt-get remove docker docker-engine docker.io containerd runc curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - apt-key fingerprint 0EBF**** add-apt-repository \ &amp;quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \ bionic \ stable&amp;quot; apt-get install docker-ce docker-ce-cli containerd.io # https://www.daocloud.io/mirror curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io docker run hello-world  Compose https://gitee.com/xipushi/dockercompose.git chmod +x docker-compose-Linux-x86_64 mv docker-compose-Linux-x86_64 docker-compose cp /use/local/bin docker-compose --version  Dockerfile # from based nginx # run start FROM nginx # exec: RUN[&amp;quot;.</description>
    </item>
    
    <item>
      <title>Makefile template</title>
      <link>https://6923403.github.io/post/makefile_template/</link>
      <pubDate>Wed, 19 Aug 2020 10:21:09 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/makefile_template/</guid>
      <description>V1  ############ 交叉编译 CROSS_COMPILE=aarch64-himix100-linux- CC=$(CROSS_COMPILE)g++ # 当前路径 PWD := $(shell pwd) #库 LIB += -lpthread -lsqlite3 #参数 CFLAG= -D_GNU_SOURCE -D__USE_XOPEN -g #.cpp源文件 SRCS=$(wildcard ./src/*.cpp) #头文件 INC=-I$(PWD)/include #中间文件 OBJS=$(SRCS:.cpp=.o) #二进制文件 BIN=maincpp #start，表示开始执行 start:$(OBJS) $(CC) -o $(BIN) $(OBJS) $(CFLAG) $(LIB) .cpp.o: $(CC) $(INC) -o $@ -c $&amp;lt; $(CFLAB) $(LIB) .PHONY : clean clean: rm -f ${BIN} ./src/*.o  V2 # Makefile cc=gcc LDFLAGS=-lncurses SRCS := $(wildcard *.c) TARGET := $(SRCS:%.c=%) $(TARGET):$(SRCS) $(cc) $(LDFLAGS) $(SRCS) -o $(TARGET) clean: rm $(TARGET)  Reference: Makefile 文件 -只有include和src文件夹</description>
    </item>
    
    <item>
      <title>GDB tutorial</title>
      <link>https://6923403.github.io/post/use_gdb/</link>
      <pubDate>Fri, 07 Aug 2020 16:45:20 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/use_gdb/</guid>
      <description>Start gdb or gdb -q # exit ctrl + d or quit  Use g++ -g main.cpp -o main gdb main -q or gdb -q file main Debug runing program
ps ux | grep showpng gdb showpng 28334 -q  CoreDump ** Check if off **
ulimit -c 0 # is off # tmp use ulimit -c unlimited ulimit -c unlimited # turn open permanent use
vim /etc/security/limits.conf # add line * soft core unlimited # and echo &amp;quot;core.</description>
    </item>
    
    <item>
      <title>Shell_command($!, $@...)</title>
      <link>https://6923403.github.io/post/shell_commans/</link>
      <pubDate>Sat, 01 Aug 2020 21:31:50 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/shell_commans/</guid>
      <description>./start.sh 1 2 3 4 num: $# = 4 PID: $$ = 24133 sname: $0 = start.sh first: $1 = 1 secont: $2 = 2 $@ = 1234 #value list $* = 1234 #value   $* 1 2 3 4  </description>
    </item>
    
    <item>
      <title>Arch Beautify desktop</title>
      <link>https://6923403.github.io/post/arch_desktop/</link>
      <pubDate>Thu, 30 Jul 2020 18:04:47 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/arch_desktop/</guid>
      <description>updat&amp;hellip;
1. install xorg pacman -S xorg-server xorg-xinit 2. install zsh, feh, i3gapsr, compton, oh-my-zsh pacman -S zsh xfce4-terminal feh compton i3-gaps nautilus i3lock sh -c &amp;quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&amp;quot;  install ttf pacman -S ttf-liberation pacman -S adobe-source-han-sans-cn-fonts pacman -S adobe-source-han-sans-tw-fonts pacman -S adobe-source-han-sans-jp-fonts  add user useradd -m -g users -s /bin/zsh xxxx #添加xxxx用户，用户名你自定义 passwd xxxx #为xxxx用户设置密码 vim /etc/sudoers #编辑配置文件 在root ALL = (ALL) ALL下添加xxxx ALL = (ALL) ALL;输入:wq!强制保存退出vim  startx exit login new user touch .</description>
    </item>
    
    <item>
      <title>Vmware install Archlinux </title>
      <link>https://6923403.github.io/post/arch_install/</link>
      <pubDate>Thu, 30 Jul 2020 16:43:47 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/arch_install/</guid>
      <description>0. Ready work Test environment: Vmware15.5.6pro arch-2020-07.iso You should installed Vmware and download Archlinux iso .
Change your firmwaretype to UEFI (The way many tutorials did not say)  1. Start ls /sys/firmware/efi/efivars The command detect UEFI files and if your dir not include files your firmwaretype is BIOS .
Then, ping google.com, detect interent connection
 Archwiki: Note: The installation image has systemd-networkd.service, systemd-resolved.service and iwd.service enabled by default. That will not be the case for the installed system.</description>
    </item>
    
    <item>
      <title>Ubuntu20 Install Nvidia drivers</title>
      <link>https://6923403.github.io/post/install_nvidia/</link>
      <pubDate>Wed, 29 Jul 2020 17:29:52 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/install_nvidia/</guid>
      <description>0.Ready work Disable BIOS secure boot，choose disable .
 1. Uninstall old Nvidia drivers sudo apt-get remove --purge nvidia*  2. Add rules vim /etc/modprobe.d/blacklist.conf
1. blacklist nouveau 2. options nouveau modeset=0  3. Verification After reboot, use the following command no return is successful
sudo update-initramfs -u lsmod | grep nouveau  4. Choose Navidia drivers version  1.Use command: ubuntu-drivers devices 2.Nvidia Official website  Choose stable version and install</description>
    </item>
    
    <item>
      <title>Linux install Boost c&#43;&#43;</title>
      <link>https://6923403.github.io/post/linux_install_boost/</link>
      <pubDate>Tue, 28 Jul 2020 13:09:01 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/linux_install_boost/</guid>
      <description>Boost C++ is Cpp programming language that provides support for tasks and structures
 Download Source https://dl.bintray.com/boostorg/release/1.73.0/source/boost_1_73_0.tar.gz tar zxvf boost(解压)  Set use GCC cd boost ./bootstrap.sh --with-libraries=all --with-toolset=gcc  Compile &amp;amp; Install boost ./b2 toolset=gcc ./b2 install --prefix=/usr  Test programming #include &amp;lt;boost/thread/thread.hpp&amp;gt; //boost thread #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; volatile bool isRuning = true; void func1() { static int cnt1 = 0; while(isRuning) { cout &amp;lt;&amp;lt; &amp;quot;func1:&amp;quot; &amp;lt;&amp;lt; cnt1++ &amp;lt;&amp;lt; endl; sleep(1); } } void func2() { static int cnt2 = 0; while(isRuning) { cout &amp;lt;&amp;lt; &amp;quot;\tfunc2:&amp;quot; &amp;lt;&amp;lt; cnt2++ &amp;lt;&amp;lt; endl; sleep(2); } } int main() { boost::thread thread1(&amp;amp;func1); boost::thread thread2(&amp;amp;func2); system(&amp;quot;read&amp;quot;); isRuning = false; thread2.</description>
    </item>
    
    <item>
      <title>Ubuntu20 install FFmpeg</title>
      <link>https://6923403.github.io/post/ffmpeg_install/</link>
      <pubDate>Mon, 27 Jul 2020 17:41:31 +0800</pubDate>
      
      <guid>https://6923403.github.io/post/ffmpeg_install/</guid>
      <description>Start Download FFmpeg  Install tool 1. install yasm
sudo apt-get install yasm  if not installed yasm, os will output &amp;ldquo;nasm/yasm not found or too old. Use &amp;ndash;disable-x86asm for a crippled build.&amp;rdquo;
 2. install SDL2
SDL2-2.0.12(stable)
tar -xvf SDL2-2.0.12.tar.gz cd SDL2-2.0.12 ./configure sudo make -j4 sudo make install  Install FFmpeg 1. git clone https://git.ffmpeg.org/ffmpeg.git ffmpeg
cd ffmpeg/ ./configure sudo make -j4 sudo make install  3. Check ffmpeg -version ffplay -version </description>
    </item>
    
  </channel>
</rss>