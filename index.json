[{"categories":null,"contents":"","permalink":"https://6923403.github.io/post/search/","tags":[],"title":"Search"},{"categories":null,"contents":"socket struct整理\nhttps://6923403.github.io/post/socket_struct/\n socket编程需要的头文件整理\nhttps://6923403.github.io/post/socket_file/\n exception_class 异常类\nhttps://6923403.github.io/post/cpp_exception/\n Linux Pthread 线程创建与使用\nhttps://6923403.github.io/post/linuxpthread/\n epoll tutorial, epoll处理教程\nhttps://6923403.github.io/post/epoll_use/\n socket function, socket函数\nhttps://6923403.github.io/post/socket/\n","permalink":"https://6923403.github.io/post/socketsum/","tags":["Socket","CPP","Linux"],"title":"Socket sum"},{"categories":null,"contents":"const 作用\n 修饰变量，变量不可以被改变； 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）； 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改； 修饰成员函数，说明该成员函数内不能修改成员变量。   // 类 class A { private: const int a; // 常对象成员，只能在初始化列表赋值 public: // 构造函数 A() : a(0) { }; A(int x) : a(x) { }; // 初始化列表 // const可用于对重载函数的区分 int getValue(); // 普通成员函数 int getValue() const; // 常成员函数，不得修改类中的任何数据成员的值 }; void function() { // 对象 A b; // 普通对象，可以调用全部成员函数、更新常成员变量 const A a; // 常对象，只能调用常成员函数 const A *p = \u0026amp;a; // 指针变量，指向常对象 const A \u0026amp;q = a; // 指向常对象的引用 // 指针 char greeting[] = \u0026quot;Hello\u0026quot;; char* p1 = greeting; // 指针变量，指向字符数组变量 const char* p2 = greeting; // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变） char* const p3 = greeting; // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变） const char* const p4 = greeting; // 自身是常量的指针，指向字符数组常量 } // 函数 void function1(const int Var); // 传递过来的参数在函数内不可变 void function2(const char* Var); // 参数指针所指内容为常量 void function3(char* const Var); // 参数指针为常量 void function4(const int\u0026amp; Var); // 引用参数在函数内为常量 // 函数返回值 const int function5(); // 返回一个常数 const int* function6(); // 返回一个指向常量的指针变量，使用：const int *p = function6(); int* const function7(); // 返回一个指向变量的常指针，使用：int* const p = function7();  const 的指针与引用  指针  指向常量的指针（pointer to const） 自身是常量的指针（常量指针，const pointer）   引用  指向常量的引用（reference to const） 没有 const reference，因为引用本身就是 const pointer     用法小结 指针\nconst int * pOne; //指向整形常量的指针，它指向的值不能修改(指针变量，指向字符数组常量) int * const pTwo; //指向整形的常量指针 ，它不能在指向别的变量，但指向（变量）的值可以修改(自身是常量的指针，指向字符数组变量) const int *const pThree; //指向整形常量的常量指针 。它既不能再指向别的常量，指向的值也不能修改(自身是常量的指针，指向字符数组常量) 类定义、类成员\n// 对象 A b; // 普通对象，可以调用全部成员函数、更新常成员变量 const A a; // 常对象，只能调用常成员函数 const A *p = \u0026amp;a; // 指针变量，指向常对象 const A \u0026amp;q = a; // 指向常对象的引用 类成员函数\nint getValue() const; //该函数为只读函数，不允许修改其中的数据成员的值。 const int getValue(); //修饰的是返回值，表示返回的是指针所指向值是常量。 引用\nint \u0026amp;a = 20; //错误 字面常量是右值 const int \u0026amp;c = b; # 常量左值引用绑定到非常量左值，编译通过 const int \u0026amp;e = c; # 常量左值引用绑定到常量左值，编译通过 const int \u0026amp;b =2; # 常量左值引用绑定到右值，编程通过 void s1(const \u0026amp;ra) //ra不可改变 ","permalink":"https://6923403.github.io/post/cppconst/","tags":["CPP","Const","Pointer"],"title":"CPP_Const"},{"categories":null,"contents":"什么是C/S和B/S架构？\nC/S架构 软件（即客户机/服务器模式）分为客户机和服务器两层：第一层是在客户机系统上结合了表示与业务逻辑，第二层是通过网络结合了数据库服务器。 简单的说就是第一层是用户表示层，第二层是数据库层。 客户端和服务器直接相连，这两个组成部分都承担着重要的角色。\nB/S架构 第一层是浏览器（即客户端）只有简单的输入输出功能，处理极少部分的事务逻辑。由于客户不需要安装客户端，只要有浏览器就能上网浏览，所以它面向的是大范围的用户，所以界面设计得比较简单，通用。\n第二层是WEB服务器，扮演着信息传送的角色。当用户想要访问数据库时，就会首先向WEB服务器发送请求，WEB服务器统一请求后会向数据库服务器发送访问数据库的请求，这个请求是以SQL语句实现的。\n第三层是数据库服务器，它存放着大量的数据。当数据库服务器收到了WEB服务器的请求后，会对SQL语句进行处理，并将返回的结果发送给WEB服务器，接下来，WEB服务器将收到的数据结果转换为HTML文本形式发送给浏览器。\n 优点/缺点 C/S架构的优点\na. 客户端和服务器直接相连。点对点的连接方式更安全，可以直接操作本地文本，比较方便。\nb. 客户端可以处理一些逻辑事务。可以进行数据处理和数据存储，提供一定的帮助。\nc. 客户端直接操作界面。\nC/S架构的缺点\na\u0026gt; C/S架构适用于局域网，对网速的要求比较高。\nb\u0026gt; 客户端界面缺乏通用性，且当业务更改时就需要更改界面，重新编写。\nc\u0026gt; 随着用户数量的增多，会出现通信拥堵、服务器响应速度慢等情况。\nd\u0026gt; 系统的维护也比较麻烦。\n B/S架构的优点  a\u0026gt; 浏览器和数据库服务器采用多对多的方式连接。因此适合在广域网里实现巨大的互联网，甚至是全球网，有着很强大的信息共享性。\nb\u0026gt; 浏览器只处理一些简单的逻辑事务，负担小。\nc\u0026gt; 数据都集中存放在数据库服务器，所以不存在数据不一致现象。\nd\u0026gt; 随着服务器负载的增加，可以平滑地增加服务器的个数并建立集群服务器系统，然后在各个服务器之间做负载均衡。\ne\u0026gt; B/S建立在广域网上，所以需要的网速要求不高。\nf\u0026gt; 不需要安装客户端，只要能连上网，就能随时随地的浏览页面。\ng\u0026gt; 能有效地保护数据平台和管理访问权限，确保服务器数据库的数据安全。\nB/S架构的缺点  a\u0026gt; 服务器承担着重要的责任，数据负荷较重。一旦发生服务器“崩溃”等问题，后果不堪设想。\nb\u0026gt; 页面需要不断地动态刷新，当用户增多时，网速会变慢。\n  第一层是浏览器（即客户端）只有简单的输入输出功能，处理极少部分的事务逻辑。由于客户不需要安装客户端，只要有浏览器就能上网浏览，所以它面向的是大范围的用户，所以界面设计得比较简单，通用。 第二层是WEB服务器，扮演着信息传送的角色。当用户想要访问数据库时，就会首先向WEB服务器发送请求，WEB服务器统一请求后会向数据库服务器发送访问数据库的请求，这个请求是以SQL语句实现的。 第三层是数据库服务器，它存放着大量的数据。当数据库服务器收到了WEB服务器的请求后，会对SQL语句进行处理，并将返回的结果发送给WEB服务器，接下来，WEB服务器将收到的数据结果转换为HTML文本形式发送给浏览器。   https://blog.csdn.net/qq_42828949/article/details/82822901\nhttps://blog.csdn.net/zhengqijun_/article/details/53056624\n","permalink":"https://6923403.github.io/post/cs_bs/","tags":["Linux","TCP"],"title":"C/S_B/S 架构"},{"categories":null,"contents":"O(1)常数阶 \u0026lt; O(logn)对数阶 \u0026lt; O(n)线性阶 \u0026lt; O(n^2)平方阶 \u0026lt; O(n^3)(立方阶) \u0026lt; O(2^n) (指数阶)\nFor O(n) int function1(int x, int n) { int result = 1; // 注意 任何数的0次方等于1 for (int i = 0; i \u0026lt; n; i++) { result = result * x; } return result; }  Recursion O(n) int function2(int x, int n) { if (n == 0) { return 1; // return 1 同样是因为0次方是等于1的 } return function2(x, n - 1) * x; }  Recursion2 O(n) int function3(int x, int n) { if (n == 0) { return 1; } if (n % 2 == 1) { return function3(x, n/2) * function3(x, n/2)*x; } return function3(x, n/2) * function3(x, n/2); }  Recursion3 O(logn) int function4(int x, int n) { if (n == 0) { return 1; } int t = function4(x, n/2);// 这里相对于function3，是把这个递归操作抽取出来 if (n % 2 == 1) { return t*t*x; } return t*t; } ","permalink":"https://6923403.github.io/post/recursion/","tags":["Algorithm","CPP","Recursion"],"title":"Algorithm x^n"},{"categories":null,"contents":"#include \u0026lt;pthread.h\u0026gt; int pthread_condattr_init(pthread_condattr_t* attr); int pthread_condattr_destroy(pthread_condattr_t* attr); //返回值：成功返回0；失败返回错误编码 pthread_condattr_init\n 功能：对条件变量属性结构体初始化 调用此函数之后，条件变量属性结构体的属性都是系统默认值，如果想要设置其他属性，还需要调用不同的函数进行设置  pthread_condattr_destroy\n 功能：对条件变量属性结构体反初始化（销毁） 只反初始化，不释放内存  Re:\nhttps://blog.csdn.net/qq_41453285/article/details/90904870\n #include \u0026lt;pthread.h\u0026gt; int pthread_condattr_setshared(pthread_condattr_t* attr,int pshared); int pthread_condattr_getshared(const pthread_condattr_t* restrict attr,int* restrict pshared); //返回值：成功返回0；失败返回错误编码 pthread_condattr_setshared\n 功能：设置条件变量的进程共享属性  pthread_condattr_getshared\n 功能：获取条件变量的进程共享属性  Re:\nhttps://blog.csdn.net/qq_41453285/article/details/90904870\n #include \u0026lt;pthread.h\u0026gt; int pthread_condattr_setclock(pthread_condattr_t* attr,clockid_t clock_id); int pthread_condattr_getclock(const pthread_condattr_t* restrict attr,clockid_t *restrict clock_id); //返回值：成功返回0；失败返回错误编码 pthread_condattr_setclock\n 功能：此函数用于设置pthread_cond_timewait函数使用的时钟ID  pthread_condattr_getclock\n 功能：此函数获取可被用于pthread_cond_timedwait函数的时钟ID。pthread_cond_timedwait函数使用前需要用pthread_condattr_t对条件变量进行初始化  Re:\nhttps://blog.csdn.net/qq_41453285/article/details/90904870\n int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr)\n其中cond是一个指向结构pthread_cond_t的指针，cond_attr是一个指向结构pthread_condattr_t的指针。结构 pthread_condattr_t是条件变量的属性结构，和互斥锁一样我们可以用它来设置条件变量是进程内可用还是进程间可用， 默认值是PTHREAD_ PROCESS_PRIVATE，即此条件变量被同一进程内的各个线程使用。\n注意初始化条件变量只有未被使用时才能重新初始化或被释放。释放一个条件变量的函数为pthread_cond_destroy（pthread_cond_t cond）。\n也可以静态的初始化条件变量\npthread_cond_t my_condition = PTHREAD_COND_INITIALIZER;  pthread_mutex_init(pthread_mutex_t * mutex, const pthread_mutexattr_t *attr); // 初始化锁变量mutex。 // attr为锁属性，NULL值为默认属性。 pthread_mutex_lock(pthread_mutex_t *mutex); // 加锁（阻塞操作） pthread_mutex_trylock(pthread_mutex_t *mutex); // 试图加锁（不阻塞操作） // 当互斥锁空闲时将占有该锁；否则立即返回 // 但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。 pthread_mutex_unlock(pthread_mutex_t *mutex); 释放锁 pthread_mutex_destroy(pthread_mutex_t *mutex); 销毁一个不再需要的互斥量，释放系统资源。 pthread_cond_wait() / pthread_cond_timedwait -----等待条件变量，挂起线程，区别是后者，会有timeout时间， 如果到了timeout,线程自动解除阻塞，这个时间和 time()系统调用相同意义的。以1970年时间算起。 pthread_cond_signal ----激活等待列表中的线程， pthread_cond_broadcast() -------激活所有等待线程列表中最先入队的线程 条件变量\n条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：\n 1）一个线程等待\u0026quot;条件变量的条件成立\u0026quot;而挂起； 2）另一个线程使\u0026quot;条件成立\u0026rdquo;（给出条件成立信号）。  为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。\n注意：\n  1）上面这几个函数都是原子操作，可以为理解为一条指令，不会被其他程序打断\n  2）上面这个几个函数，必须配合使用。\n  3）pthread_cond_wait，先会解除当前线程的互斥锁，然后挂线线程，等待条件变量满足条件。一旦条件变量满足条件，则会给线程上锁，继续执行pthread_cond_wait\n  返回值:\npthread_mutex_lock() 和 pthread_mutex_unlock() 返回0，否则返回一个错误的提示码\npthread_mutex_trylock() 在成功获得了一个mutex的锁后返回0，否则返回一个错误提示码错误\npthread_mutex_lock() 和 pthread_mutex_unlock()失败的时候 [EINVAL] mutex在生成的时候，它的protocol属性的值是 PTHREAD_PRIO_PROTECT，同时调用线程的优先级(priority)比该mutex的当前prority上限高\nhttps://blog.csdn.net/u012109245/article/details/38662371\nhttps://www.jianshu.com/p/af0ec2eded33\n int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);\n 第一个参数为指向线程标识符的指针。 第二个参数用来设置线程属性。 第三个参数是线程运行函数的起始地址。 最后一个参数是运行函数的参数。  int pthread_join(pthread_t thread, void **retval);\n  thread: 需要等待的线程,指定的线程必须位于当前的进程中，而且不得是分离线程\n  retval: 线程tid所执行的函数返回值（返回值地址需要保证有效），其中status可以为NULL\n  https://blog.csdn.net/liangxanhai/article/details/7767430\nhttps://blog.csdn.net/wushuomin/article/details/80051295\nhttps://blog.csdn.net/lovecodeless/article/details/24885127\n","permalink":"https://6923403.github.io/post/linuxpthread/","tags":["Linux","Pthread","CPP"],"title":"Linux Pthread"},{"categories":null,"contents":"class derived-class: access-specifier base-class\nclass Shape { public: void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // 派生类 class Rectangle: public Shape { public: int getArea() { return (width * height); } }; Rectangle rect; rect.setWidth(3); rect.setHeight(5); #rect result = 15 cout \u0026lt;\u0026lt; rect.getArea() \u0026lt;\u0026lt; endl;  访问控制和继承\n   访问 public protected private     同一个类 yes yes yes   派生类 yes yes no   外部的类 yes no no     公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。 保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。 私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。  ","permalink":"https://6923403.github.io/post/cpp_inherit/","tags":["CPP"],"title":"Cpp_inherit"},{"categories":null,"contents":"   Mysql ex     mysql_init() 获取或初始化MYSQL结构   mysql_real_connect() 连接到MySQL服务器。   mysql_query() 执行指定为“以Null终结的字符串”的SQL查询   mysql_use_result() 初始化逐行的结果集检索   mysql_field_count() 返回上次执行语句的结果集的列数   mysql_fetch_row() 从结果集中获取下一行   mysql_num_fields() 返回结果集中的字段数     class MyDB { public: MyDB(); ~MyDB(); bool initDB(string host, string user, string pwd, string db_name); bool exeSQL(string sql); private: MYSQL *connection; MYSQL_RES *result; MYSQL_ROW row; };  基本步骤\n使用mysql_init()初始化连接 使用mysql_real_connect()建立一个到mysql数据库的连接 使用mysql_query()执行查询语句 result = mysql_use_result(conn)获取结果集 mysql_field_count(conn)获取查询的列数，mysql_num_fields(result)获取结果集的字段数 通过mysql_fetch_row(result)不断获取下一行，然后循环输出 释放结果集所占内存mysql_free_result(result) mysql_close(conn)关闭连接  Re:\nhttps://blog.csdn.net/lisonglisonglisong/article/details/25071793\n","permalink":"https://6923403.github.io/post/mysql_use/","tags":["Mysql","CPP","Linux"],"title":"CPP_Mysql_use"},{"categories":null,"contents":"Configure the package management system (yum) vim /etc/yum.repos.d/mongodb-org-4.4.repo\n[mongodb-org-4.4] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.4/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-4.4.asc  Install Mongodb sudo yum install -y mongodb-org  Directory Paths sudo mkdir -p /var/lib/mongo sudo mkdir -p /var/log/mongodb sudo chown -R mongod:mongod /var/lib/mongo sudo chown -R mongod:mongod /var/log/mongodb Start mongodb sudo systemctl start mongod sudo systemctl status mongod sudo systemctl enable mongod mongo //use  Re:\nhttps://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/\n","permalink":"https://6923403.github.io/post/install_mongodb/","tags":["Linux","Mongodb"],"title":"Centos7 Install mongodb"},{"categories":null,"contents":"升级GCC yum -y install centos-release-scl yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils scl enable devtoolset-9 bash echo \u0026quot;source /opt/rh/devtoolset-9/enable\u0026quot; \u0026gt;\u0026gt; /etc/profile gcc -v  安装redis wget http://download.redis.io/releases/redis-6.0.8.tar.gz tar -xvf redis-6.0.8/tar/gz cd redis make -j4 make install PREFIX=/usr/local/redis  配置redis cd redis cp redis.conf /usr/local/redis/bin/ vim /usr/local/redis/bin/redis.conf\ndaemonize no 改为 daemonize yes  开机自启 vim /etc/systemd/system/redis.service\n[Unit] Description=redis-server After=network.target [Service] Type=forking ExecStart=/usr/local/redis/bin/redis-server /usr/local/redis/bin/redis.conf PrivateTmp=true [Install] WantedBy=multi-user.target systemctl daemon-reload ln -s /usr/local/redis/bin/redis-cli /usr/bin/redis systemctl start redis.service systemctl enable redis.service  Re:\nhttps://blog.csdn.net/wanTN/article/details/108502856\n","permalink":"https://6923403.github.io/post/install_redis/","tags":["Linux","Redis"],"title":"Centos7 Install_redis"},{"categories":null,"contents":"1.添加Mysql5.7仓库 sudo rpm -ivh https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm\n2.确认Mysql仓库成功添加 sudo yum repolist all | grep mysql | grep enabled\n3.安装Mysql5.7 sudo yum -y install mysql-community-server\n4.启动Mysql sudo systemctl start mysqld\n5.设置系统启动时自动启动 sudo systemctl enable mysqld\n6.查看启动状态 sudo systemctl status mysqld\n7.root 密码 cat /var/log/mysqld.log | grep -i 'temporary password'\n8.执行下面命令进行安全设置 这个命令会进行设置root密码设置，移除匿名用户，禁止root用户远程连接等\nmysql_secure_installation\n9.设置数据库编码为utf8 sudo vim /etc/my.cnf\n[client] default-character-set=utf8 [mysql] default-character-set=utf8 [mysqld] collation-server = utf8_unicode_ci init-connect='SET NAMES utf8' character-set-server = utf8 reboot sudo systemctl restart mysqld\n Re:\nhttps://juejin.im/post/6844903732145045517\n","permalink":"https://6923403.github.io/post/install_mysql/","tags":["Mysql","Linux"],"title":"Centos7 Install mysql"},{"categories":null,"contents":"#include \u0026lt;unistd.h\u0026gt; int getopt(int argc, char * const argv[], const char *optstring); extern char *optarg; extern int optind, opterr, optopt; #include \u0026lt;getopt.h\u0026gt; int getopt_long(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex); int getopt_long_only(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex);  static struct option Vcopts[] = { {\u0026quot;device\u0026quot;, required_argument, NULL, 'd'}, {\u0026quot;savefile\u0026quot;, optional_argument, NULL, 'f'}, {\u0026quot;help\u0026quot;, no_argument, NULL, 'h'}, {\u0026quot;version\u0026quot;, no_argument, NULL, 'v'}, {\u0026quot;Device list\u0026quot;, no_argument, NULL, 'l'}, {\u0026quot;http-proxy\u0026quot;, required_argument, \u0026amp;lopt, 1}, {0, 0, 0, 0} };  no_argument: -h --h, -v --v required_argument: -d/ -d ens33/ -d = ens33 optional_argument: -f filename/ -f = filename \u0026amp;lopt: \u0026ndash;http-proxy=127.0.0.1:80 getopt_long return 0, lopt return 1   Re:\nhttps://blog.csdn.net/qq_33850438/article/details/80172275\n","permalink":"https://6923403.github.io/post/getopt_long/","tags":["Linux","CPP"],"title":"getopt_long"},{"categories":null,"contents":"创建数据库 CREATE DATABASE IF NOT EXISTS vctest DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 2. CREATE DATABASE IF NOT EXISTS mytestdb;\n删除数据库 drop database test1; 2. DROP DATABASE IF EXISTS mytestdb;\n查看All DB show databases;\n导入sql source test.sql\n select\nuse vctest select city, phone, country from `offices`; SELECT语句由以下列表中所述的几个子句组成：\n语句中的SELECT和FROM语句是必须的，其他部分是可选的。\n SELECT之后是逗号分隔列或星号(*)的列表，表示要返回所有列。 FROM指定要查询数据的表或视图。 JOIN根据某些连接条件从其他表中获取数据。 WHERE过滤结果集中的行。 GROUP BY将一组行组合成小分组，并对每个小分组应用聚合函数。 HAVING过滤器基于GROUP BY子句定义的小分组。 ORDER BY指定用于排序的列的列表。 LIMIT限制返回行的数量。  即使WHERE子句出现在语句的末尾，但MySQL会首先使用WHERE子句中的表达式来选择匹配的行。\nSELECT lastname, firstname, jobtitle FROM employees WHERE jobtitle = 'Sales Rep';  INSERT 创建表\nCREATE TABLE [IF NOT EXISTS] table_name( column_list ) engine=table_type;  首先，指定要在CREATE TABLE子句之后创建的表的名称。表名在数据库中必须是唯一的。 IF NOT EXISTS是语句的可选部分，允许您检查正在创建的表是否已存在于数据库中。 如果是这种情况，MySQL将忽略整个语句，不会创建任何新的表。 强烈建议在每个CREATE TABLE语句中使用IF NOT EXISTS来防止创建已存在的新表而产生错误。 其次，在column_list部分指定表的列表。字段的列用逗号(，)分隔。我们将在下一节中向您展示如何更详细地列(字段)定义。 第三，需要为engine子句中的表指定存储引擎。可以使用任何存储引擎，如：InnoDB，MyISAM，HEAP，EXAMPLE，CSV，ARCHIVE，MERGE， FEDERATED或NDBCLUSTER。如果不明确声明存储引擎，MySQL将默认使用InnoDB。  //为表定义列 column_name data_type[size] [NOT NULL|NULL] [DEFAULT value] [AUTO_INCREMENT]  column_name指定列的名称。每列具有特定数据类型和大小，例如：VARCHAR(255)。 NOT NULL或NULL表示该列是否接受NULL值。 DEFAULT值用于指定列的默认值。 AUTO_INCREMENT指示每当将新行插入到表中时，列的值会自动增加。每个表都有一个且只有一个AUTO_INCREMENT列。 PRIMARY KEY (col1,col2,\u0026hellip;) 设为主键  USE testdb; CREATE TABLE IF NOT EXISTS tasks ( task_id INT(11) AUTO_INCREMENT, subject VARCHAR(45) DEFAULT NULL, start_date DATE DEFAULT NULL, end_date DATE DEFAULT NULL, description VARCHAR(200) DEFAULT NULL, PRIMARY KEY (task_id) )ENGINE=InnoDB DEFAULT CHARSET=utf8; ALTER TABLE语句来设置列的自动递增属性\nALTER TABLE tasks CHANGE COLUMN task_id task_id INT(11) NOT NULL AUTO_INCREMENT; 添加新列\nALTER TABLE tasks ADD COLUMN complete DECIMAL(2,1) NULL AFTER description; 删除列\nALTER TABLE tasks DROP COLUMN description; 重命名表\nALTER TABLE tasks RENAME TO work_items; 2. RENAME TABLE old_table_name TO new_table_name;  插入数据\nINSERT INTO tasks(subject,start_date,end_date,description) //插入到tasks表中 VALUES('Learn MySQL INSERT','2017-07-21','2017-07-22','Start learning..'); 插入多行\nINSERT INTO table(column1,column2...) VALUES (value1,value2,...), (value1,value2,...), (value1, value2,...);  复制表结构\nCREATE TABLE tasks_bak LIKE tasks; INSERT INTO tasks_bak SELECT * FROM tasks;  MySQL INSERT与ON DUPLICATE KEY UPDATE\nINSERT INTO tasks(task_id,subject,start_date,end_date,description) VALUES (4,'Test ON DUPLICATE KEY UPDATE','2017-01-01','2017-01-02','Next Priority') ON DUPLICATE KEY UPDATE task_id = task_id + 1, subject = 'Test ON DUPLICATE KEY UPDATE'; 等同于UPDATE语句\nUPDATE tasks SET task_id = task_id + 1, subject = 'Test ON DUPLICATE KEY UPDATE' WHERE task_id = 4;  UPDATE\nUPDATE employees SET lastname = 'NKS', email = 'mary.new@yiibai.com' WHERE employeeNumber = 1056; 随机选择一个职位是Sales Rep的员工\nSELECT employeeNumber FROM employees WHERE jobtitle = 'Sales Rep' ORDER BY RAND() LIMIT 1; 需要更新customers表中的销售代表员工编号(employeeNumber)列\nUPDATE customers SET salesRepEmployeeNumber = (SELECT employeeNumber FROM employees WHERE jobtitle = 'Sales Rep' LIMIT 1) WHERE salesRepEmployeeNumber IS NULL;  备份数据库\nhttps://www.yiibai.com/mysql/how-to-backup-database-using-mysqldump.html\n DELETE\n删除表 DROP TABLE IF EXISTS tasks;\n删除指定条件\nDELETE FROM employees WHERE officeCode = 4; 删除表中所有行 delete from employees;\n删除指定行数\nDELETE FROM customers ORDER BY customerName LIMIT 10; //10行 删除五个法国客户\nDELETE FROM customers WHERE country = 'France' ORDER BY creditLimit LIMIT 5;  创建函数\nDELIMITER // CREATE PROCEDURE get_employee(IN p_id INT) begin SELECT first_name ,last_name ,dept_name FROM employees INNER JOIN departments using (department_id) WHERE id = p_id; END; // DELIMITER; 运行 CALL get_employee(1);\n Mysql技巧 https://www.yiibai.com/mysql/mysqltips.html\nMySQL存储过程 https://www.yiibai.com/mysql/stored-procedure.html\nRe:\nhttps://www.yiibai.com/mysql\nhttps://stackoverflow.com/questions/3401982/error-with-mysql-procedures-error-1304-error-1305\nhttps://blog.csdn.net/yuxin6866/article/details/52722913\n","permalink":"https://6923403.github.io/post/mysqluse/","tags":["Mysql","Linux"],"title":"Mysql_use"},{"categories":null,"contents":"形参（形式参数）\n在函数定义中出现的参数可以看做是一个占位符，它没有数据，只能等到函数被调用时接收传递进来的数据，所以称为形式参数，简称形参。\n实参（实际参数）\n函数被调用时给出的参数包含了实实在在的数据，会被函数内部的代码使用，所以称为实际参数，简称实参。\n形参和实参的功能是传递数据，发生函数调用时，实参的值会传递给形参。\n Re: http://c.biancheng.net/view/1853.html   左值和右值\nhttp://c.biancheng.net/view/1510.html\n 常量和变量\nhttps://www.runoob.com/cprogramming/c-variables.html\nhttps://www.runoob.com/cprogramming/c-constants.html\nhttp://c.biancheng.net/cpp/html/19.html\n","permalink":"https://6923403.github.io/post/leftright/","tags":["CPP"],"title":"Left_Right"},{"categories":null,"contents":"https://zhuanlan.zhihu.com/p/33074506\nhttps://www.runoob.com/w3cnote/c-volatile-keyword.html\n","permalink":"https://6923403.github.io/post/volatile/","tags":["CPP","Volatile"],"title":"About function: Volatile"},{"categories":null,"contents":"struct sockaddr { unsigned short sa_family; /* address family, AF_xxx */ char sa_data[14]; /* 14 bytes of protocol address */ }; 此数据结构用做bind、connect、recvfrom、sendto等函数的参数，指明地址信息。\n 但一般编程中并不直接针对此数据结构操作，而是使用另一个与sockaddr等价的数据结构sockaddr_in（在netinet/in.h中定义）：\nstruct sockaddr_in { short int sin_family; /* Address family */ unsigned short int sin_port; /* Port number */ struct in_addr sin_addr; /* Internet address */ unsigned char sin_zero[8]; /* Same size as struct sockaddr */ }; 在编程中大多数是使用sockaddr_in这个结构来设置/获取地址信息\n  sin_family指代协议族，在socket编程中只能是AF_INET\n  sin_port存储端口号（使用网络字节顺序）\n  sin_addr存储IP地址，使用in_addr这个数据结构\n   struct in_addr { unsigned long s_addr; }; 这个数据结构是由于历史原因保留下来的，主要用作与以前的格式兼容。\ns_addr按照网络字节顺序存储IP地址\nsin_zero是为了让sockaddr与sockaddr_in两个数据结构保持大小相同而保留的空字节\n 设置地址信息的示例：\nstruct sockaddr_in sa; sa.sin_family = AF_INET; sa.sin_port = htons(3490); /* short, NBO*/ sa.sin_addr.s_addr = inet_addr(\u0026quot;132.241.5.10\u0026quot;); bzero(\u0026amp;(sa.sin_zero), 8); 注意：如果sa.sin_addr.s_addr ＝ INADDR_ANY，则不指定IP地址（用于Server程序）\n","permalink":"https://6923403.github.io/post/socket_struct/","tags":["Sokcet","Linux","CPP"],"title":"Socket struct"},{"categories":null,"contents":"socket编程中需要用到的头文件\n  sys/types.h：数据类型定义\n  sys/socket.h：提供socket函数及数据结构\n  netinet/in.h：定义数据结构sockaddr_in\n  arpa/inet.h：提供IP地址转换函数\n  netdb.h：提供设置及获取域名的函数\n  sys/ioctl.h：提供对I/O控制的函数\n  sys/poll.h：提供socket等待测试机制的函数\n   其他在网络程序中常见的头文件\n  unistd.h：提供通用的文件、目录、程序及进程操作的函数\n  errno.h：提供错误号errno的定义，用于错误处理\n  fcntl.h：提供对文件控制的函数\n  time.h：提供有关时间的函数\n  crypt.h：提供使用DES加密算法的加密函数\n  pwd.h：提供对/etc/passwd文件访问的函数\n  shadow.h：提供对/etc/shadow文件访问的函数\n  pthread.h：提供多线程操作的函数\n  signal.h：提供对信号操作的函数\n  sys/wait.h、sys/ipc.h、sys/shm.h：提供进程等待、进程间通讯（IPC）及共享内存的函数\n   建议：在编写网络程序时，可以直接使用下面这段头文件代码\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netdb.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt;  涉及到用户权限及密码验证问题时加入如下语句：\n#include \u0026lt;shadow.h\u0026gt; #include \u0026lt;crypt.h\u0026gt; #include \u0026lt;pwd.h\u0026gt; 需要注意的是，应该在编译时链接加密算法库，即增加编译选项：-lcrypt\n 涉及到文件及时间操作加入如下语句\n#include \u0026lt;sys/time.h\u0026gt; #include \u0026lt;utime.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/file.h\u0026gt;  涉及到多进程操作时加入如下语句\n#include \u0026lt;sys/wait.h\u0026gt; #include \u0026lt;sys/ipc.h\u0026gt; #include \u0026lt;sys/shm.h\u0026gt; #include \u0026lt;signal.h\u0026gt;  涉及到多线程操作时加入如下语句\n#include \u0026lt;pthread.h\u0026gt; #include \u0026lt;sys/poll.h\u0026gt; 需要注意的是，应该在编译时链接线程库，即增加编译选项：-lthread\n","permalink":"https://6923403.github.io/post/socket_file/","tags":["Socket","Linux","CPP"],"title":"Socket file"},{"categories":null,"contents":"class exception{ public: exception () throw(); //构造函数 exception (const exception\u0026amp;) throw(); //拷贝构造函数 exception\u0026amp; operator= (const exception\u0026amp;) throw(); //运算符重载 virtual ~exception() throw(); //虚析构函数 virtual const char* what() const throw(); //虚函数 } what() 函数返回一个能识别异常的字符串，正如它的名字“what”一样，可以粗略地告诉你这是什么异常。\n exception 类的继承层次:  exception 类 直接派生类\n   exceptopn explain     login_error logic error   runtime_error 运行时错误   bad_alloc 使用 new 或 new[] 分配内存失败时抛出的异常   bad_typeid 使用 typeid 操作一个 NULL 指针，而且该指针是带有虚函数的类，这时抛出 bad_typeid 异常   bad_cast 使用 dynamic_cast 转换失败时抛出的异常   ios_base::failure io 过程中出现的异常   bad_exception 这是个特殊的异常，如果函数的异常列表里声明了 bad_exception 异常，当函数内部抛出了异常列表中没有的异常时，如果调用的 unexpected() 函数中抛出了异常，不论什么类型，都会被替换为 bad_exception 类型     logic_error 的派生类\n   异常名称 说明     length_error 试图生成一个超出该类型最大长度的对象时抛出该异常，例如 vector 的 resize 操作   domain_error 参数的值域错误，主要用在数学函数中，例如使用一个负值调用只能操作非负数的函数   out_of_range 超出有效范围   invalid_argument 参数不合适。在标准库中，当利用string对象构造 bitset 时，而 string 中的字符不是 0 或1 的时候，抛出该异常     runtime_error 的派生类\n   异常名称 说明     range_error 计算结果超出了有意义的值域范围   overflow_error 算术计算上溢   underflow_error 算术计算下溢     Re:\nhttp://c.biancheng.net/cpp/biancheng/view/3028.html\n","permalink":"https://6923403.github.io/post/cpp_exception/","tags":["CPP","Linux","exception"],"title":"Cpp exception class"},{"categories":null,"contents":"获取Backtrace #include \u0026lt;execinfo.h\u0026gt; /* Store up to SIZE return address of the current program state in ARRAY and return the exact number of values stored. */ int backtrace(void **array, int size); /* Return names of functions from the backtrace list in ARRAY in a newly malloc()ed memory block. */ char **backtrace_symbols(void *const *array, int size); /* This function is similar to backtrace_symbols() but it writes the result immediately to a file. */ void backtrace_symbols_fd(void *const *array, int size, int fd); int backtrace(void **buffer,int size)\n该函数用与获取当前线程的调用堆栈,获取的信息将会被存放在buffer中,它是一个指针数组。参数 size 用来指定buffer中可以保存多少个void* 元素。函数返回值是实际获取的指针个数,最大不超过size大小在buffer中的指针实际是从堆栈中获取的返回地址,每一个堆栈框架有一个返回地址。\n注意某些编译器的优化选项对获取正确的调用堆栈有干扰,另外内联函数没有堆栈框架;删除框架指针也会使无法正确解析堆栈内容\n char ** backtrace_symbols (void *const *buffer, int size)\nbacktrace_symbols将从backtrace函数获取的信息转化为一个字符串数组. 参数buffer应该是从backtrace函数获取的数组指针,size是该数组中的元素个数(backtrace的返回值)，函数返回值是一个指向字符串数组的指针,它的大小同buffer相同.每个字符串包含了一个相对于buffer中对应元素的可打印信息.它包括函数名，函数的偏移地址,和实际的返回地址\n void backtrace_symbols_fd (void *const *buffer, int size, int fd)\nbacktrace_symbols_fd与backtrace_symbols 函数具有相同的功能,不同的是它不会给调用者返回字符串数组,而是将结果写入文件描述符为fd的文件中,每个函数对应一行.它不需要调用malloc函数,因此适用于有可能调用该函数会失败的情况。\n  使用它们的时候有一下几点需要我们注意的地方：\n   backtrace的实现依赖于栈指针（fp寄存器），在gcc编译过程中任何非零的优化等级（-On参数）或加入了栈指针优化参数-fomit-frame-pointer后多将不能正确得到程序栈信息；\n  backtrace_symbols的实现需要符号名称的支持，在gcc编译过程中需要加入-rdynamic参数；\n  内联函数没有栈帧，它在编译过程中被展开在调用的位置；\n  尾调用优化（Tail-call Optimization）将复用当前函数栈，而不再生成新的函数栈，这将导致栈信息不能正确被获取。\n  Re:\nhttps://blog.csdn.net/jxgz_leo/article/details/53458366\nhttps://www.cnblogs.com/mickole/p/3246702.html\n","permalink":"https://6923403.github.io/post/backtrace/","tags":["Linux","CPP","Backtrace"],"title":"Linux cpp put Backtrace"},{"categories":null,"contents":"#include \u0026lt;iostream\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; int main() { std::string str = \u0026quot;Hello\u0026quot;; std::vector\u0026lt;std::string\u0026gt; v; //调用常规的拷贝构造函数，新建字符数组，拷贝数据 v.push_back(str); std::cout \u0026lt;\u0026lt; \u0026quot;After copy, str is \\\u0026quot;\u0026quot; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026quot;\\\u0026quot;\\n\u0026quot;; //调用移动构造函数，掏空str，掏空后，最好不要使用str v.push_back(std::move(str)); std::cout \u0026lt;\u0026lt; \u0026quot;After move, str is \\\u0026quot;\u0026quot; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026quot;\\\u0026quot;\\n\u0026quot;; std::cout \u0026lt;\u0026lt; \u0026quot;The contents of the vector are \\\u0026quot;\u0026quot; \u0026lt;\u0026lt; v[0] \u0026lt;\u0026lt; \u0026quot;\\\u0026quot;, \\\u0026quot;\u0026quot; \u0026lt;\u0026lt; v[1] \u0026lt;\u0026lt; \u0026quot;\\\u0026quot;\\n\u0026quot;; } Cout:\nAfter copy, str is \u0026quot;Hello\u0026quot; After move, str is \u0026quot;\u0026quot; The contents of the vector are \u0026quot;Hello\u0026quot;, \u0026quot;Hello\u0026quot;  函数原型 template \u0026lt;typename T\u0026gt; typename remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp; move(T\u0026amp;\u0026amp; t) { return static_cast\u0026lt;typename remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp;\u0026gt;(t); }  原型定义中的原理实现: 公式一）X\u0026amp; \u0026amp;、X\u0026amp;\u0026amp; \u0026amp;、X\u0026amp; \u0026amp;\u0026amp;都折叠成X\u0026amp;，用于处理左值\nstring s(\u0026quot;hello\u0026quot;); std::move(s) =\u0026gt; std::move(string\u0026amp; \u0026amp;\u0026amp;) =\u0026gt; 折叠后 std::move(string\u0026amp; ) 此时：T的类型为string\u0026amp; typename remove_reference\u0026lt;T\u0026gt;::type为string 整个std::move被实例化如下 string\u0026amp;\u0026amp; move(string\u0026amp; t) //t为左值，移动后不能在使用t { //通过static_cast将string\u0026amp;强制转换为string\u0026amp;\u0026amp; return static_cast\u0026lt;string\u0026amp;\u0026amp;\u0026gt;(t); } 公式二）X\u0026amp;\u0026amp; \u0026amp;\u0026amp;折叠成X\u0026amp;\u0026amp;，用于处理右值\nstd::move(string(\u0026quot;hello\u0026quot;)) =\u0026gt; std::move(string\u0026amp;\u0026amp;) //此时：T的类型为string // remove_reference\u0026lt;T\u0026gt;::type为string //整个std::move被实例如下 string\u0026amp;\u0026amp; move(string\u0026amp;\u0026amp; t) //t为右值 { return static_cast\u0026lt;string\u0026amp;\u0026amp;\u0026gt;(t); //返回一个右值引用 } 右值经过T\u0026amp;\u0026amp;传递类型保持不变还是右值，而左值经过T\u0026amp;\u0026amp;变为普通的左值引用.\n②.对于static_cast\u0026lt;\u0026gt;的使用注意：任何具有明确定义的类型转换，只要不包含底层const,都可以使用static_cast。\ndouble d = 1; void* p = \u0026amp;d; double *dp = static_cast\u0026lt;double*\u0026gt; p; //正确 const char *cp = \u0026quot;hello\u0026quot;; char *q = static_cast\u0026lt;char*\u0026gt;(cp); //错误：static不能去掉const性质 static_cast\u0026lt;string\u0026gt;(cp); //正确 ③对于remove_reference是通过类模板的部分特例化进行实现的\n//原始的，最通用的版本 template \u0026lt;typename T\u0026gt; struct remove_reference{ typedef T type; //定义T的类型别名为type }; //部分版本特例化，将用于左值引用和右值引用 template \u0026lt;class T\u0026gt; struct remove_reference\u0026lt;T\u0026amp;\u0026gt; //左值引用 { typedef T type; } template \u0026lt;class T\u0026gt; struct remove_reference\u0026lt;T\u0026amp;\u0026amp;\u0026gt; //右值引用 { typedef T type; } //举例如下,下列定义的a、b、c三个变量都是int类型 int i; remove_refrence\u0026lt;decltype(42)\u0026gt;::type a; //使用原版本， remove_refrence\u0026lt;decltype(i)\u0026gt;::type b; //左值引用特例版本 remove_refrence\u0026lt;decltype(std::move(i))\u0026gt;::type b; //右值引用特例版本  总结： std::move实现，首先，通过右值引用传递模板实现，利用引用折叠原理将右值经过T\u0026amp;\u0026amp;传递类型保持不变还是右值，而左值经过T\u0026amp;\u0026amp;变为普通的左值引用，以保证模板可以传递任意实参，且保持类型不变。\n然后我们通过static_cast\u0026lt;\u0026gt;进行强制类型转换返回T\u0026amp;\u0026amp;右值引用，而static_cast之所以能使用类型转换，是通过remove_refrence::type模板移除T\u0026amp;\u0026amp;，T\u0026amp;的引用，获取具体类型T。\n Re https://blog.csdn.net/p942005405/article/details/84644069\n","permalink":"https://6923403.github.io/post/move/","tags":["CPP","Liux","move"],"title":"Cpp11 move"},{"categories":null,"contents":"create_thread Ex   1.导入#include\u0026mdash;用于创建线程\n  2.导入#include\u0026ndash;用于时间延时 获取时间之类的\n  定义一个线程对象t1，这就自动创建了一个线程，参数就是你要线程去执行的函数，t1是变量名字 随便取\nstd::thread t1(func);\n下面这里返回一个毫秒级别的时间间隔参数值，间隔10毫秒\nstd::chrono::milliseconds(10) this_thread::sleep_for（）就是让此线程休眠，可以传入休眠的时间 this_thread::sleep_for(std::chrono::milliseconds(10));让本线程休眠10毫秒  thread4\n join()就是阻塞线程 阻塞的目的就是让Main主线程等待一下创建的线程，免得我函数还在跑，程序就直接结束了。 detach()将线程与线程对象分离   thread5\nc++11还提供了一个lock_guard类，它利用了RAII机制可以保证安全释放mutex。\n在std::lock_guard对象构造时，传入的mutex对象(即它所管理的mutex对象)会被当前线程锁住。\n在lock_guard对象被析构时，它所管理的mutex对象会自动解锁，不需要程序员手动调用lock和unlock对mutex进行上锁和解锁操作。\nlock_guard对象并不负责管理mutex对象的生命周期，lock_guard对象只是简化了mutex对象的上锁和解锁操作，方便线程对互斥量上锁，即在某个lock_guard对象的生命周期内，它所管理的锁对象会一直保持上锁状态；\n而lock_guard的生命周期结束之后，它所管理的锁对象会被解锁。程序员可以非常方便地使用lock_guard，而不用担心异常安全问题。\n thread6\nc++11还提供了std::unique_lock\n类 unique_lock 是通用互斥包装器，允许延迟锁定、锁定的有时限尝试、递归锁定、所有权转移和与条件变量一同使用。 unique_lock比lock_guard使用更加灵活，功能更加强大。 使用unique_lock需要付出更多的时间、性能成本。  thread7\n互斥量很像的条件变量的知识\n条件变量std::condition_variable的使用 std::condition_variable 是为了解决死锁而生的。 当互斥操作不够用而引入的。\n比如，线程可能需要等待某个条件为真才能继续执行，而一个忙等待循环中可能会导致所有其他线程都无法进入临界区使得条件为真时，就会发生死锁。所以，condition_variable实例被创建出现主要就是用于唤醒等待线程从而避免死锁。\nstd::condition_variable:\n notify_one()用于唤醒一个线程； notify_all() 则是通知所有线程。  C++11中的std::condition_variable就像Linux下使用pthread_cond_wait和pthread_cond_signal一样，可以让线程休眠，直到被唤醒，现在在从新执行。线程等待在多线程编程中使用非常频繁，经常需要等待一些异步执行的条件的返回结果。\n thread8\n原子变量的使用\n在新标准C++11，引入了原子操作的概念，原子操作更接近内核，并通过这个新的头文件提供了多种原子操作数据类型.\n例如，atomic_bool,atomic_int等等，如果我们在多个线程中对这些类型的共享资源进行操作，编译器将保证这些操作都是原子性的，也就是说，确保任意时刻只有一个线程对这个资源进行访问，编译器将保证，多个线程访问这个共享资源的正确性。从而避免了锁的使用，提高了效率。\n thread9\nfuture与promise的使用\n在c++11中增加的线程库很方便的让我们去使用线程，但是因为做出了一些改变，我们并不能像往常一样直接使用thread.join()获取线程函数的返回值了，而我们有时候又确实要利用线程函数的返回值。\nthread库提供了future用来访问异步操作的结果，因为一个异步操作的结果往往不能立即获取，只能在未来的某个时候从某个地方获取，这个异步操作的结果是一个未来的期待值，所以被称为future .\n future和promise的作用是在不同线程之间传递数据。\n 假设线程1需要线程2的数据，那么组合使用方式如下:\n  线程1初始化一个promise对象和一个future对象，promise传递给线程2，相当于线程2对线程1的一个承诺；future相当于一个接受一个承诺，用来获取未来线程2传递的值\n  线程2获取到promise后，需要对这个promise传递有关的数据，之后线程1的future就可以获取数据了。\n  如果线程1想要获取数据，而线程2未给出数据，则线程1阻塞，直到线程2的数据到达\n   thread10\nfuture与package_task的使用\nstd::packaged_task包装一个可调用的对象，并且允许异步获取该可调用对象产生的结果。\nstd::packaged_task将其包装的可调用对象的执行结果传递给一个std::future对象，与std::promise某种程度上是很像的，promise保存一个共享状态的值，而package_task保存的是一个函数。\n thread11\n线程异步操作函数async的用法\nstd::async比std::packaged_task，std::promise中，std::thread更高一层，它可以直接用来创建异步的task，异步的结果也保存在future中。完成后，外面再通过future.get/wait来获取这个未来的结果，强烈推荐使用async，我们不需要关注异步任务的结果，只要等待任务完成获取值就行了。\n现在来看看std::async的原型async(std::launch::async | std::launch::deferred, f, args...)，第一个参数是线程的创建策略，有两种策略，默认的策略是立即创建线程：\n std::launch::async 在调用async就开始创建线程。 std::launch::deferred 延迟加载方式创建线程。调用async时不创建线程，直到调用了future的get或者wait时才创建线程。  第二个参数是线程函数，第三个参数是线程函数的参数。\n thread12\nstd::future::wait_for()函数作用\ntemplate\u0026lt; class Rep, class Period \u0026gt; std::future_status wait_for( const std::chrono::duration\u0026lt;Rep,Period\u0026gt;\u0026amp; timeout_duration ) const; 等待结果变得可用。阻塞直至经过指定的 timeout_duration ，或结果变为可用，两者的先到来者。返回值鉴别结果的状态。\n此函数可能由于调度或资源争议延迟而阻塞长于 timeout_duration 。\n推荐标准库用稳定时钟度量时长。若实现用系统时钟代替，则等待时间可能也对时钟调整敏感。\n若调用此函数前 valid()== false 则行为未定义。\n   参数 解释     future_status::deferred 要计算结果的函数仍未启动   future_status::ready 结果就绪   future_status::timeout 已经过时限    异常\n 时钟、时间点或时长在执行中可能抛的任何异常（标准库提供的时钟、时间点和时长决不抛出）。  注意\n 鼓励实现在调用前检测 valid == false 的情况并抛出以 future_errc::no_state 为 error_condition 的 future_error .   Re:\nhttps://www.cnblogs.com/DOMLX/p/10945309.html\n","permalink":"https://6923403.github.io/post/cppthread/","tags":["CPP","thread"],"title":"CPP11_thread"},{"categories":null,"contents":"epoll是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。\nepoll除了提供select/poll那种IO事件的水平触发（Level Triggered）外，还提供了边缘触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。\n  水平触发（LT）：默认工作模式，即当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序可以不立即处理该事件；下次调用epoll_wait时，会再次通知此事件\n  边缘触发（ET）： 当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次通知此事件。（直到你做了某些操作导致该描述符变成未就绪状态了，也就是说边缘触发只在状态由未就绪变为就绪时只通知一次）。\n   #include \u0026lt;sys/epoll.h\u0026gt; epoll与select Epoll 没有最大并发连接的限制，上限是最大可以打开文件的数目 效率提升，epoll对于句柄事件的选择不是遍历的，是事件响应的，就是句柄上事件来就马上选择出来，不需要遍历整个句柄链表，因此效率非常高，内核将句柄用红黑树保存的，IO效率不随FD数目增加而线性下降。 内存拷贝， select让内核把 FD 消息通知给用户空间的时候使用了内存拷贝的方式，开销较大，但是Epoll 在这点上使用了共享内存的方式，这个内存拷贝也省略了。 相比于select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。因为在内核中的select实现中，它是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。 并且，在linux/posix_types.h头文件有这样的声明： #define __FD_SETSIZE 1024 表示select最多同时监听1024个fd，当然，可以通过修改头文件再重编译内核来扩大这个数目，但这似乎并不治本。\n epoll_create int epoll_create(int size); 创建一个epoll的句柄，\nsize用来告诉内核这个监听的数目一共有多大。 这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。\n epoll_ctl int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); epoll_ctl(_iEpollfd, op, fd, \u0026amp;ev); //Error:_iEpollfd: -1. Success: _iEpollfd = fd epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型\nEPOLL_CTL_ADD 注册新的fd到epfd中； EPOLL_CTL_MOD 修改已经注册的fd的监听事件； EPOLL_CTL_DEL 从epfd中删除一个fd；\nfd 是要监听的fd\nevent 是要监听什么样的事件\n typedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; struct epoll_event { uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ }; events可以是以下几个宏的集合:\n  EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；\n  EPOLLOUT：表示对应的文件描述符可以写；\n  EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；\n  EPOLLERR：表示对应的文件描述符发生错误；\n  EPOLLHUP：表示对应的文件描述符被挂断；\n  EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。\n  EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里\n   epoll_wait int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); 等待事件的产生，类似于select()调用。\n参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。\n ET、LT两种工作模式：   EPOLLLT：完全靠Linux-kernel-epoll驱动，应用程序只需要处理从epoll_wait返回的fds， 这些fds我们认为它们处于就绪状态。此时epoll可以认为是更快速的poll。\n  EPOLLET：此模式下，系统仅仅通知应用程序哪些fds变成了就绪状态，一旦fd变成就绪状态，epoll将不再关注这个fd的任何状态信息(从epoll队列移除), 直到应用程序通过读写操作（非阻塞）触发EAGAIN状态，epoll认为这个fd又变为空闲状态，那么epoll又重新关注这个fd的状态变化(重新加入epoll队列)。 随着epoll_wait的返回，队列中的fds是在减少的，所以在大并发的系统中，EPOLLET更有优势，但是对程序员的要求也更高。\n  假设现在对方发送了2k的数据，而我们先读取了1k，然后这时调用了epoll_wait，如果是边沿触发ET，那么这个fd变成就绪状态就会从epoll 队列移除， 则epoll_wait 会一直阻塞，忽略尚未读取的1k数据; 而如果是水平触发LT，那么epoll_wait 还会检测到可读事件而返回，我们可以继续读取剩下的1k 数据。 总结: LT模式可能触发的次数更多, 一旦触发的次数多, 也就意味着效率会下降; 但这样也不能就说LT模式就比ET模式效率更低 因为ET的使用对编程人员提出了更高更精细的要求,一旦使用者编程水平不够, 那ET模式还不如LT模式。 ET模式仅当状态发生变化的时候才获得通知,这里所谓的状态的变化并不包括缓冲区中还有未处理的数据, 也就是说,如果要采用ET模式,需要一直read/write直到出错为止,很多人反映为什么采用ET模式只接收了一部分数据就再也得不到通知了,大多因为这样; 而LT模式是只要有数据没有处理就会一直通知下去的.  epoll IO多路复用模型实现机制 设想一下如下场景：有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？ 在select/poll时代，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll一般只能处理几千的并发连接。 epoll的设计和实现与select完全不同。epoll通过在Linux内核中申请一个简易的文件系统，把原先的select/poll调用分成了3个部分：\n  调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源)\n  调用epoll_ctl向epoll对象中添加这100万个连接的套接字\n  调用epoll_wait收集发生的事件的连接\n  只需要在进程启动时建立一个epoll对象，然后在需要的时候向这个epoll对象中添加或者删除连接。同时，epoll_wait的效率也非常高，因为调用epoll_wait时，并没有一股脑的向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接。\n Linux内核具体的epoll机制实现思路 当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关\n/* * This structure is stored inside the \u0026quot;private_data\u0026quot; member of the file * structure and rapresent the main data sructure for the eventpoll * interface. */ struct eventpoll { /* Protect the this structure access */ spinlock_t lock; /* * This mutex is used to ensure that files are not removed * while epoll is using them. This is held during the event * collection loop, the file cleanup path, the epoll file exit * code and the ctl operations. */ struct mutex mtx; /* Wait queue used by sys_epoll_wait() */ wait_queue_head_t wq; /* Wait queue used by file-\u0026gt;poll() */ wait_queue_head_t poll_wait; /* List of ready file descriptors */ /*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/ struct list_head rdllist; /*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/ /* RB tree root used to store monitored fd structs */ struct rb_root rbr; /* * This is a single linked list that chains all the \u0026quot;struct epitem\u0026quot; that * happened while transfering ready events to userspace w/out * holding -\u0026gt;lock. */ struct epitem *ovflist; /* The user that created the eventpoll descriptor */ struct user_struct *user; }; 每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是lgn，其中n为树的高度)。\n而所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。\n在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示:\n/* * Each file descriptor added to the eventpoll interface will * have an entry of this type linked to the \u0026quot;rbr\u0026quot; RB tree. */ struct epitem { /* RB tree node used to link this structure to the eventpoll RB tree */ //红黑树节点 struct rb_node rbn; /* List header used to link this structure to the eventpoll ready list */ //双向链表节点 struct list_head rdllink; /* * Works together \u0026quot;struct eventpoll\u0026quot;-\u0026gt;ovflist in keeping the * single linked chain of items. */ struct epitem *next; /* The file descriptor information this item refers to */ //事件句柄信息 struct epoll_filefd ffd; /* Number of active wait queue attached to poll operations */ int nwait; /* List containing poll wait queues */ struct list_head pwqlist; /* The \u0026quot;container\u0026quot; of this item */ //指向其所属的eventpoll对象 struct ![Uploading EPOLL_663944.jpg . . .] eventpoll *ep; /* List header used to link this item to the \u0026quot;struct file\u0026quot; items list */ struct list_head fllink; /* The structure that describe the interested events and the source fd */ //期待发生的事件类型 struct epoll_event event; }; 当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。\n通过红黑树和双链表数据结构，并结合回调机制，造就了epoll的高效。\n Re:\nhttps://www.jianshu.com/p/718c24af400f\nhttps://www.bbsmax.com/A/l1dymR3Gde/\nhttps://www.jianshu.com/p/397449cadc9a\n","permalink":"https://6923403.github.io/post/epoll_use/","tags":["Linux","Socket","CPP"],"title":"epoll use"},{"categories":null,"contents":"setsockopt\n获取或者设置与某个套接字关联的选 项。选项可能存在于多层协议中，它们总会出现在最上面的套接字层。当操作套接字选项时， 选项位于的层和选项的名称必须给出。为了操作套接字层的选项，应该 将层的值指定为SOL_SOCKET。为了操作其它层的选项，控制选 项的合适协议号必须给出。例如，为了表示一个选项由TCP协议解析，层应该设定为协议 号TCP。 SO_LINGER选项\nstruct linger { int l_onoff; int l_linger; }; Re: https://segmentfault.com/a/1190000019360464\nhttps://www.cnblogs.com/eeexu123/p/5275783.html\n epoll_ctl(_iEpollfd, op, fd, \u0026amp;ev); //Error:_iEpollfd: -1. Success: _iEpollfd = fd\n int fcntl(int fd, int cmd); int fcntl(int fd, int cmd, long arg); int fcntl(int fd, int cmd, struct flock *lock); fcntl函数有5种功能：\n 1.复制一个现有的描述符（cmd=F_DUPFD）. 2.获得／设置文件描述符标记(cmd=F_GETFD或F_SETFD). 3.获得／设置文件状态标记(cmd=F_GETFL或F_SETFL). 4.获得／设置异步I/O所有权(cmd=F_GETOWN或F_SETOWN). 5.获得／设置记录锁(cmd=F_GETLK,F_SETLK或F_SETLKW).  Re: https://www.cnblogs.com/xuyh/p/3273082.html\n 非阻塞I/O使我们的操作要么成功，要么立即返回错误，不被阻塞。\n对于一个给定的描述符两种方法对其指定非阻塞I/O:\n 1.调用open获得描述符，并指定O_NONBLOCK标志 2.对已经打开的文件描述符，调用fcntl，打开O_NONBLOCK文件状态标志。  flags = fcntl( s, F_GETFL, 0 ) ) fcntl( s, F_SETFL, flags | O_NONBLOCK ) Re: https://blog.csdn.net/zhulinfeiba/article/details/5011573\n  htonl()\u0026ndash;\u0026ldquo;Host to Network Long int\u0026rdquo; 32Bytes  将主机的无符号长整形数转换成网络字节顺序。//将无符号长整型网络字节序转换为主机字节序\n ntohl()\u0026ndash;\u0026ldquo;Network to Host Long int\u0026rdquo; 32Bytes  将一个无符号长整形数从网络字节顺序转换为主机字节顺序。\n htons()\u0026ndash;\u0026ldquo;Host to Network Short int\u0026rdquo; 16Bytes  将主机的无符号短整形数转换成网络字节顺序。//将无符号短整型主机字节序转换为网络字节序\n ntohs()\u0026ndash;\u0026ldquo;Network to Host Short int\u0026rdquo; 16Bytes  将一个无符号短整形数从网络字节顺序转换为主机字节顺序。\n inet_addr()  将一个点间隔地址转换成一个in_addr\n inet_ntoa()  是编程语言，功能是将网络地址转换成“.”点隔的字符串格式。\n inet_aton()  与inet_ntoa()作用相反。本函数将点分十进制转换为整数\n atoi()  array to integer将字符串转换为整形数\n 新型网路地址转化函数inet_pton和inet_ntop 这两个函数是随IPv6出现的函数，对于IPv4地址和IPv6地址都适用，函数中p和n分别代表表达（presentation)和数值（numeric)。地址的表达格式通常是ASCII字符串，数值格式则是存放到套接字地址结构的二进制值。\n#include \u0026lt;arpe/inet.h\u0026gt; int inet_pton(int family, const char *strptr, void *addrptr); //将点分十进制的ip地址转化为用于网络传输的数值格式 返回值：若成功则为1，若输入不是有效的表达式则为0，若出错则为-1 const char * inet_ntop(int family, const void *addrptr, char *strptr, size_t len); //将数值格式转化为点分十进制的ip地址格式 返回值：若成功则为指向结构的指针，若出错则为NULL   1.这两个函数的family参数既可以是AF_INET（ipv4）也可以是AF_INET6（ipv6）。如果，以不被支持的地址族作为family参数，这两个函数都返回一个错误，并将errno置为EAFNOSUPPORT.\n  2.第一个函数尝试转换由strptr指针所指向的字符串，并通过addrptr指针存放二进制结果，若成功则返回值为1，否则如果所指定的family而言输入字符串不是有效的表达式格式，那么返回值为0.\n  3.inet_ntop进行相反的转换，从数值格式（addrptr）转换到表达式（strptr)。inet_ntop函数的strptr参数不可以是一个空指针。调用者必须为目标存储单元分配内存并指定其大小，调用成功时，这个指针就是该函数的返回值。len参数是目标存储单元的大小，以免该函数溢出其调用者的缓冲区。如果len太小，不足以容纳表达式结果，那么返回一个空指针，并置为errno为ENOSPC。\n  inet_pton(AF_INET, ip, \u0026amp;foo.sin_addr); // 代替 foo.sin_addr.addr=inet_addr(ip); char str[INET_ADDRSTRLEN]; char *ptr = inet_ntop(AF_INET,\u0026amp;foo.sin_addr, str, sizeof(str)); // 代替 ptr = inet_ntoa(foo.sin_addr) 示例代码\nint main() { char IPdotdec[20]; // 存放点分十进制IP地址 struct in_addr s; // IPv4地址结构体 // 输入IP地址 printf(\u0026quot;Please input IP address: \u0026quot;); scanf(\u0026quot;%s\u0026quot;, \u0026amp;IPdotdec); // 转换 inet_pton(AF_INET, IPdotdec, (void *)\u0026amp;s); printf(\u0026quot;inet_pton: 0x%x\\n\u0026quot;, s.s_addr); // 注意得到的字节序 // 反转换 inet_ntop(AF_INET, (void *)\u0026amp;s, IPdotdec, 16); printf(\u0026quot;inet_ntop: %s\\n\u0026quot;, IPdotdec); } Run: Please input IP address: 127.0.0.1 inet_pton: 0x100007f inet_ntop: 127.0.0.1 Re: https://blog.csdn.net/zyy617532750/article/details/58595700\nhttps://www.cnblogs.com/wuyuxuan/p/10772779.html\n int send( SOCKET s,char *buf,int len,int flags )\n功能：不论是客户还是服务器应用程序都用send函数来向TCP连接的另一端发送数据。客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答。\n  参数一：指定发送端套接字描述符；\n  参数二：存放应用程序要发送数据的缓冲区；\n  参数三：实际要发送的数据的字节数；\n  参数四：一般置为0。\n  int recv( SOCKET s, char *buf, int len, int flags)\n功能：不论是客户还是服务器应用程序都用recv函数从TCP连接的另一端接收数据。\n  参数一：指定接收端套接字描述符；\n  参数二：指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；\n  参数三：指明buf的长度；\n  参数四 ：一般置为0。\n  Re: https://blog.csdn.net/lanzhihui_10086/article/details/40681617\n read(sock, buf, sizeof(buf) -1)\nread从套接字文件中读取数据, fd为要读取的文件的描述符，buf为要接收数据的缓冲区地址，nbytes为要读取的数据的字节数。\n  /* * 本函数向服务ip发起请求 服务器ip port 保存在sockaddr_in中 * int connect(int sock, struct sockaddr *serv_addr, socklen_t addrlen); //Linux * int connect(SOCKET sock, const struct sockaddr *serv_addr, int addrlen); //Windows * sock 为 socket 文件描述符，addr 为 sockaddr 结构体变量的指针，addrlen 为 addr 变量的大小，可由 sizeof() 计算得出。 */ connect(sock, (struct sockaddr*) \u0026amp;serv_addr, sizeof(serv_addr));  linux mutex block\npthread_mutexattr_t mattr\nint pthread_mutexattr_init(pthread_mutexattr_t *mattr)\npthread_mutex_init() 函数是以动态方式创建互斥锁的，参数attr指定了新建互斥锁的属性。如果参数attr为空，则使用默认的互斥锁属性，默认属性为快速互斥锁 。互斥锁的属性在创建锁的时候指定，在LinuxThreads实现中仅有一个锁类型属性，不同的锁类型在试图对一个已经被锁定的互斥锁加锁时表现不同。\n Success: return 0  POSIX定义了一个宏PTHREAD_MUTEX_INITIALIZER来静态初始化互斥锁\npthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER; 动态方式是采用pthread_mutex_init()函数来初始化互斥锁\nint pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr) 其中mutexattr用于指定互斥锁属性（见下），如果为NULL则使用缺省属性, pthread_mutex_destroy()用于注销一个互斥锁\nint pthread_mutex_destroy(pthread_mutex_t *mutex) 销毁一个互斥锁即意味着释放它所占用的资源，且要求锁当前处于开放状态。由于在Linux中，互斥锁并不占用任何资源，因此LinuxThreads中的 pthread_mutex_destroy()除了检查锁状态以外（锁定状态则返回EBUSY）没有其他动作。\n2.属性 3. 锁操作\nRe: https://www.cnblogs.com/lidabo/p/4566693.html\n 互斥锁的类型：有以下几个取值空间:\n  PTHREAD_MUTEX_TIMED_NP，这是缺省值，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性。\n  PTHREAD_MUTEX_RECURSIVE_NP，嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争。\n  PTHREAD_MUTEX_ERRORCHECK_NP，检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁。\n  PTHREAD_MUTEX_ADAPTIVE_NP，适应锁，动作最简单的锁类型，仅等待解锁后重新竞争。 *pthread_mutexattr_settype(pthread_mutexattr_t attr , int type) **pthread_mutexattr_gettype(pthread_mutexattr_t attr , int type)\n  Re: https://blog.csdn.net/happylzs2008/article/details/89067028\n 销毁互斥锁属性对象\n pthread_mutexattr_destroy(3C) 可用来取消分配用于维护 pthread_mutexattr_init() 所创建的属性对象的存储空间。  对于互斥锁属性对象，必须首先通过调用pthread_mutexattr_destroy(3C)将其销毁，才能重新初始化该对象。pthread_mutexattr_init() 调用会导致分配类型为 opaque 的对象。如果未销毁该对象，则会导致内存泄漏\nRe: https://blog.csdn.net/jasmineal/article/details/8807744\n 对锁的操作主要包括加锁 pthread_mutex_lock()、解锁pthread_mutex_unlock()和测试加锁 pthread_mutex_trylock()三个。\n int pthread_mutex_lock(pthread_mutex_t *mutex) int pthread_mutex_unlock(pthread_mutex_t *mutex) int pthread_mutex_trylock(pthread_mutex_t *mutex)  pthread_mutex_trylock()语义与pthread_mutex_lock()类似，不同的是在锁已经被占据时返回EBUSY而不是挂起等待\npthread_mutex_lock 用于解决由于竞争产生的优先级反转问题。没锁更新所有权,锁住\nRe: https://blog.csdn.net/jasmineal/article/details/8807744\nhttps://blog.csdn.net/oqqYuJi12345678/article/details/100585669\n backtrace backtrace_symbols backtrace_symbols_fd To: https://6923403.github.io/post/backtrace/\n pthread_cond_broadcast(\u0026amp;cond1)的作用是唤醒所有正在pthread_cond_wait(\u0026amp;cond1,\u0026amp;mutex1)的线程。\nwhile(lock_status_[lid] == LOCKED) { pthread_cond_wait(\u0026amp;c_, \u0026amp;m_); } pthread_cond_broadcast(\u0026amp;c_); 一旦某个锁被释放，所有的阻塞线程都会被唤醒，但唯有阻塞在这个锁的线程才能真正被唤醒。\npthread_cond_signal(\u0026amp;cond1)的的作用是唤醒所有正在 pthread_cond_wait(\u0026amp;cond1,\u0026amp;mutex1)的至少一个线程。（虽然我还没碰到过多于一个线程的情况，但是man帮组手册上说的是至少一个）\nRe:\nhttps://www.cnblogs.com/XiaoXiaoShuai-/p/11855408.html\nhttps://www.cnblogs.com/zhouzhuo/p/3781511.html\n struct hostent{ char *h_name; //official name char **h_aliases; //alias list int h_addrtype; //host address type int h_length; //address lenght char **h_addr_list; //address list }  h_name：官方域名（Official domain name）。官方域名代表某一主页，但实际上一些著名公司的域名并未用官方域名注册。 h_aliases：别名，可以通过多个域名访问同一主机。同一 IP 地址可以绑定多个域名，因此除了当前域名还可以指定其他域名。 h_addrtype：gethostbyname() 不仅支持 IPv4，还支持 IPv6，可以通过此成员获取IP地址的地址族（地址类型）信息，IPv4 对应 AF_INET，IPv6 对应 AF_INET6。 h_length：保存IP地址长度。IPv4 的长度为 4 个字节，IPv6 的长度为 16 个字节。 h_addr_list：这是最重要的成员。通过该成员以整数形式保存域名对应的 IP 地址。对于用户较多的服务器，可能会分配多个 IP 地址给同一域名，利用多个服务器进行均衡负载。  gethostbyname\nstruct hostent *gethostbyname(const char *hostname);\ngethostbyaddr 根据ip地址获取主机的完整信息\nstruct hostent *gethostbyaddr(const void *addr, socklen_t len, int type);\nRe:\nhttp://c.biancheng.net/view/2357.html\n getservbyname 根据名称获取某个服务的完整信息\nstruct servent *getservbyname(const char *name, const char *proto)\ngetservbyport 根据端口号获取某个服务的完整信息\nstruct servent *getservbyport(int port, const char *proto)\ngetaddrinfo 通过主机名获得IP地址也能通过服务名获得端口号\nint getaddrinfo(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res);\n之后用freeaddrinfo 释放getaddrinfo所分配的内存\nvoid freeaddrinfo(struct addrinfo *res);\ngetnameinfo 通过socket地址同时获得字符串表示的主机名和服务名\nint getnameinfo(const struct sockaddr *addr, socklen_t addrlen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, int flags);\n readv 将数据从文件描述符读到分散的内存块中\nssize_t readv(int fd, const struct iovec *iov, int iovcnt);\nwritev 将多块分散的数据一并写入文件描述符中\nssize_t writev(int fd, const struct iovec *iov, int iovcnt);\nsendfile 在两个文件描述符之间传递数据 避免内核缓冲区和用户之间的数据拷贝-零拷贝\nssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);\n mmap 申请一段内存空间 将这段内存作为进程间通信的共享内存,可以将文件直接映射到其中\nvoid *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); munmap 释放mmap创建的内存空间\nint munmap(void *addr, size_t length);\nsplice 用于在两个文件描述符之间移动数据-零拷贝\nssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags);\n","permalink":"https://6923403.github.io/post/socket/","tags":["Linux","CPP","Socket"],"title":"Socket function"},{"categories":null,"contents":"Install docker apt-get remove docker docker-engine docker.io containerd runc curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - apt-key fingerprint 0EBF**** add-apt-repository \\ \u0026quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ bionic \\ stable\u0026quot; apt-get install docker-ce docker-ce-cli containerd.io # https://www.daocloud.io/mirror curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io docker run hello-world  Compose https://gitee.com/xipushi/dockercompose.git chmod +x docker-compose-Linux-x86_64 mv docker-compose-Linux-x86_64 docker-compose cp /use/local/bin docker-compose --version  Dockerfile # from based nginx # run start FROM nginx # exec: RUN[\u0026quot;./go\u0026quot;, \u0026quot;dev\u0026quot;, \u0026quot;offline\u0026quot;] RUN echo 'Nginx image' \u0026gt; /usr/share/nginx/html/index.html # '.' is up and down content path docker build -t nginx:tesst .  Command Copy\n# 'check' file head COPY check* /testdir/ # 'check?.log' check1.log COPY check?.log /testdir/ # nickdir all files, not dir COPY nickdir . # nickdir all files, have dir COPY nickdir ./nickdir ADD\nADD url CMD \u0026amp;\u0026amp; ENTRYPOINT\nENTRYPOINT [\u0026quot;nginx\u0026quot;, \u0026quot;-c\u0026quot;] # const CMD [\u0026quot;/etc/nginx/nginx.conf\u0026quot;] # variable # run nginx -c /etc/nginx/nginx.conf ENV\nENV \u0026lt;key\u0026gt; \u0026lt;value\u0026gt; ENV \u0026lt;key1\u0026gt;=\u0026lt;value1\u0026gt; \u0026lt;key2\u0026gt;=\u0026lt;value2\u0026gt;... ENV NODE_VERSION 7.2.0 RUN curl -SLO \u0026quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz\u0026quot; \\ \u0026amp;\u0026amp; curl -SLO \u0026quot;https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc\u0026quot; ARG\nARG \u0026lt;name\u0026gt;[=\u0026lt;default value\u0026gt;] ARG CONT_IMG_VER volume expose workdir use healthcheck onbuild\n","permalink":"https://6923403.github.io/post/docker_tutorial/","tags":["Linux","Docker"],"title":"Docker use Tutorial"},{"categories":null,"contents":"V1  ############ 交叉编译 CROSS_COMPILE=aarch64-himix100-linux- CC=$(CROSS_COMPILE)g++ # 当前路径 PWD := $(shell pwd) #库 LIB += -lpthread -lsqlite3 #参数 CFLAG= -D_GNU_SOURCE -D__USE_XOPEN -g #.cpp源文件 SRCS=$(wildcard ./src/*.cpp) #头文件 INC=-I$(PWD)/include #中间文件 OBJS=$(SRCS:.cpp=.o) #二进制文件 BIN=maincpp #start，表示开始执行 start:$(OBJS) $(CC) -o $(BIN) $(OBJS) $(CFLAG) $(LIB) .cpp.o: $(CC) $(INC) -o $@ -c $\u0026lt; $(CFLAB) $(LIB) .PHONY : clean clean: rm -f ${BIN} ./src/*.o  V2 # Makefile cc=gcc LDFLAGS=-lncurses SRCS := $(wildcard *.c) TARGET := $(SRCS:%.c=%) $(TARGET):$(SRCS) $(cc) $(LDFLAGS) $(SRCS) -o $(TARGET) clean: rm $(TARGET)  Reference: Makefile 文件 -只有include和src文件夹\n","permalink":"https://6923403.github.io/post/makefile_template/","tags":["CPP","Linux","Makefile"],"title":"Makefile template"},{"categories":null,"contents":"  性质1:在二叉树的第i层上至多有2 i-1 个结点(i≥1)。\n  性质2:深度为k的二叉树至多有2 k -1个结点(k≥1)。\n  性质3:对任何一棵二叉树T,如果其终端结点数为n 0 ,度为2的结点数 为n 2 ,则n 0 =n 2 +1。\n  性质4:具有n个结点的完全二叉树的深度为|log 2 n+1|(|x|表示不大于x 的最大整数)。\n  性质5:如果对一棵有n个结点的完全二叉树(其深度为)的结点按层序 编号(从第1层到第层,每层从左到右),对任一结点i(1≤i≤n)有:\n   1.如果i=1,则结点i是二叉树的根,无双亲;如果i\u0026gt;1,则其双亲是结 点。\n  2.如果2i\u0026gt;n,则结点i无左孩子(结点i为叶子结点);否则其左孩子是 结点2i。\n  3.如果2i+1\u0026gt;n,则结点i无右孩子;否则其右孩子是结点2i+1。\n  树转换为二叉树 将树转换为二叉树的步骤如下\n  1.加线。在所有兄弟结点之间加一条连 线。\n  2.去线。对树中每个结点,只保留它与第一个孩子结点的连线,删 除它与其他孩子结点之间的连线。\n  3.层次调整。以树的根结点为轴心, 将整棵树顺时针旋转一定的角度,使之结构层次分明。注意第一个孩子 是二叉树结点的左孩子,兄弟转换过来的孩子是结点的右孩子\n   森林转换为二叉树 森林是由若干棵树组成的,所以完全可以理解为,森林中的每一棵树都是兄弟,可以按照兄弟的处理办法来操作 .\n 1.把每个树转换为二叉树。 2.第一棵二叉树不动,从第二棵二叉树开始,依次把后一棵 二叉树的根结点作为前一棵二叉树的根结点的右孩子,用线连接起来。 当所有的二叉树连接起来后就得到了由森林转换来的二叉树。   二叉树转换为树 二叉树转换为树是树转换为二叉树的逆过程,也就是反过来做而已。\n 1.加线。若某结点的左孩子结点存在,则将 这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右 孩子结点\u0026hellip;\u0026hellip;哈,反正就是左孩子的n个右孩子结点都作为此结点的孩 子。将该结点与这些右孩子结点用线连接起来。 2.去线。删除原二叉树中所有结点与其右孩子结点的连线。 3.层次调整。使之结构层次分明。   二叉树转换为森林 判断一棵二叉树能够转换成一棵树还是森林,标准很简单,那就是只要 看这棵二叉树的根结点有没有右孩子,有就是森林,没有就是一棵树。\n 1.从根结点开始,若右孩子存在,则把与右孩子结点的连线删除,再查看分离后的二叉树,若右孩子存在,则连线删除\u0026hellip;\u0026hellip;,直到所有右孩子连线都删除为止,得到分离的二 叉树。 2.再将每棵分离后的二叉树转换为树即可。   树与森林的遍历 树的遍历分为两种方式。\n 1.一种是先根遍历树,即先访问树的根结点, 然后依次先根遍历根的每棵子树。 2.另一种是后根遍历,即先依次后根 遍历每棵子树,然后再访问根结点。比如图tree6/7中右下方的树,它的 先根遍历序列为ABEFCDG,后根遍历序列为EFBCGDA。  森林的遍历也分为两种方式:\n 1.前序遍历:先访问森林中第一棵树的根 结点,然后再依次先根遍历根的每棵子树,再依次用同样方式遍历除去 第一棵树的剩余树构成的森林。比如图6-11-5下面三棵树的森林,前序 遍历序列的结果就是ABCDEFGHJI。 2.后序遍历:是先访问森林中第一 棵树,后根遍历的方式遍历每棵子树,然后再访问根结点,再依次同样 方式遍历除去第一棵树的剩余树构成的森林。比如图6-11-5下面三棵树 的森林,后序遍历序列的结果就是BCDAFEJHIG。  ","permalink":"https://6923403.github.io/post/binart_tree/","tags":["CPP","Algorithm","DataStruct","BinaryTree"],"title":"Binary Tree"},{"categories":null,"contents":" Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。 Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。   1.shared_ptr shared_ptr\u0026lt;T\u0026gt; sp\n多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。\n 支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁   3. make_shared make_shared\u0026lt;T\u0026gt;(args)\nshared_ptr\u0026lt;int\u0026gt; p = make_shared\u0026lt;int\u0026gt;(42); 返回一个shared_ptr, 指向一个动态分配的类型为T的对象。使用args初始化此对象\n 3.weak_ptr weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。\n 可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题   4.unique_ptr unique_ptr\u0026lt;T\u0026gt; up\nunique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。\n unique_ptr 用于取代 auto_ptr   5.auto_ptr 被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 std::move 语义，以及其他瑕疵。\nReference(1-5): github/Interview\n 6.Other p.get() 返回p中保存的指针。 若智能指针释放了其对象，返回的指针所指向的对象也就消失了。\np.use_count() 返回与p共享对象的智能指针数量 用于调试\np.unqiue() 若p.use_count = 1, return true; 反之 return false\n","permalink":"https://6923403.github.io/post/cpp_auto_ponit/","tags":["CPP","point"],"title":"C++ auto ponit"},{"categories":null,"contents":"0.Array int url[10]; //true int url[6 + 4] //true int len = 10; int url[len] //flase  1.Constexpr #include \u0026lt;iostream\u0026gt; using namespace std; int main() { /* * If have not constexpr, CPP throw error */ constexpr int num = 1 + 2 + 3; int url[num] = {1,2,3,4,5,6}; couts\u0026lt;\u0026lt; url[1] \u0026lt;\u0026lt; endl; return 0; }  2.Only have one \u0026lsquo;return\u0026rsquo; # Error constexpr int display(int x) { int ret = 1 + 2 + x; return ret; } # True constexpr int display(int x) { return 1 + 2 + x; }  3.Must have \u0026lsquo;return\u0026rsquo; # Error constexpr void display() { ... } # True constexpr int display() { ... }  4.Must have funciion declaration #include \u0026lt;iostream\u0026gt; using namespace std; int noconst_dis(int x); // constexpr constexpr int display(int x); constexpr int display(int x){ return 1 + 2 + x; } int main() { int a[display(3)] = { 1,2,3,4 }; cout \u0026lt;\u0026lt; a[2] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; noconst_dis(3) \u0026lt;\u0026lt; endl; return 0; } int noconst_dis(int x) { return 1 + 2 + x; }  5.\u0026lsquo;Return\u0026rsquo; must constant expession #include \u0026lt;iostream\u0026gt; using namespace std; int num = 3; constexpr int display(int x){ return num + x; } int main() { //display(3) not is constant int a[display(3)] = { 1,2,3,4 }; return 0; }  6.Constexpr struct # Error #include \u0026lt;iostream\u0026gt; using namespace std; constexpr struct myType { const char* name; int age; }; int main() { constexpr struct myType mt { \u0026quot;zhangsan\u0026quot;, 10 }; cout \u0026lt;\u0026lt; mt.name \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; mt.age \u0026lt;\u0026lt; endl; return 0; } # True #include \u0026lt;iostream\u0026gt; using namespace std; struct myType { constexpr myType(char *name,int age):name(name),age(age){}; const char* name; int age; }; int main() { constexpr struct myType mt { \u0026quot;zhangsan\u0026quot;, 10 }; cout \u0026lt;\u0026lt; mt.name \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; mt.age \u0026lt;\u0026lt; endl; return 0; }  7. CLass #include \u0026lt;iostream\u0026gt; using namespace std; //自定义类型的定义 class myType { public: constexpr myType(const char *name,int age):name(name),age(age){}; constexpr const char * getname(){ return name; } /* * unsupport virtual function */ constexpr int getage(){ return age; } private: const char* name; int age; //其它结构体成员 }; int main() { constexpr struct myType mt { \u0026quot;zhangsan\u0026quot;, 10 }; constexpr const char * name = mt.getname(); constexpr int age = mt.getage(); cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; endl; return 0; }  8.Template #include \u0026lt;iostream\u0026gt; using namespace std; struct myType { const char* name; int age; }; template\u0026lt;typename T\u0026gt; constexpr T dispaly(T t){ return t; } int main() { struct myType stu{\u0026quot;zhangsan\u0026quot;,10}; struct myType ret = dispaly(stu); cout \u0026lt;\u0026lt; ret.name \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; ret.age \u0026lt;\u0026lt; endl; constexpr int ret1 = dispaly(10); cout \u0026lt;\u0026lt; ret1 \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://6923403.github.io/post/constexpr/","tags":["CPP","const","function"],"title":"Constexpr"},{"categories":null,"contents":"Start gdb or gdb -q # exit ctrl + d or quit  Use g++ -g main.cpp -o main gdb main -q or gdb -q file main Debug runing program\nps ux | grep showpng gdb showpng 28334 -q  CoreDump ** Check if off **\nulimit -c 0 # is off # tmp use ulimit -c unlimited ulimit -c unlimited # turn open permanent use\nvim /etc/security/limits.conf # add line * soft core unlimited # and echo \u0026quot;core.%e.%p.%t\u0026quot; \u0026gt;/proc/sys/kernel/core_pattern gdb core\ngdb core* -q # or gdb -q core core*  List 1. list num\ngdb main -q list 7 # or l 7 2. list func\nl main 3. list range\nlist 1,20  Debug 1. start start set temp-block\nstart 2. next run to the next line\nnext # or n 3. next num\n# run 3 rows continuously n 3  Step Run the next line of code\nstep # or s  Break 1. Set break\nbreak 10 # or b 10 2. See break\n# info b i b 3. you can use \u0026lsquo;run\u0026rsquo; or \u0026lsquo;r\u0026rsquo;\nrun # or r 4. delete break\n#d num d 1 5. tempbreak\ntb 100 6. continue\n#continue run program c  backtrace 1. Print function stack frame, trace back the entire call process\nbt 2. Partial printing\nbt full 3. current function stack frame\ni frame 4. choose function stack frame\nbt f 1 5. Print function local variables\ninfo locals  Value 1. Print value and modify value(p \u0026amp; set) int i = 0\np i # 0 set var i = 10 p i # 10 2. View value type\nptype error  Thread status 1. Info threads\ni threads 2. Print specified thread stack\nthread apply 3 bt 3. Print all thread stack\nthread apply all bt  Use-GUI gdb file -tui -q   Re: https://github.com/DAN-AND-DNA/learn-gdb-by-example-for-c\n ","permalink":"https://6923403.github.io/post/use_gdb/","tags":["GDB","Linux","CPP"],"title":"GDB tutorial"},{"categories":null,"contents":"./start.sh 1 2 3 4 num: $# = 4 PID: $$ = 24133 sname: $0 = start.sh first: $1 = 1 secont: $2 = 2 $@ = 1234 #value list $* = 1234 #value   $* 1 2 3 4  ","permalink":"https://6923403.github.io/post/shell_commans/","tags":["Linux","shell"],"title":"Shell_command($!, $@...)"},{"categories":null,"contents":"updat\u0026hellip;\n1. install xorg pacman -S xorg-server xorg-xinit 2. install zsh, feh, i3gapsr, compton, oh-my-zsh pacman -S zsh xfce4-terminal feh compton i3-gaps nautilus i3lock sh -c \u0026quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026quot;  install ttf pacman -S ttf-liberation pacman -S adobe-source-han-sans-cn-fonts pacman -S adobe-source-han-sans-tw-fonts pacman -S adobe-source-han-sans-jp-fonts  add user useradd -m -g users -s /bin/zsh xxxx #添加xxxx用户，用户名你自定义 passwd xxxx #为xxxx用户设置密码 vim /etc/sudoers #编辑配置文件 在root ALL = (ALL) ALL下添加xxxx ALL = (ALL) ALL;输入:wq!强制保存退出vim  startx exit login new user touch .zshrc cp /etc/X11/xinit/xinitrc ~/.xinitrc vim .xinitrc exec compton -b \u0026amp; exec i3 reboot startx  安装 Yaourt vim /etc/pacman.conf\n[archlinuxcn] #The Chinese Arch Linux communities packages. SigLevel = Optional TrustAll Server = https://mirrors.aliyun.com/archlinuxcn/$arch Server = http://repo.archlinuxcn.org/$arch pacman -Syu pacman -S yaourt pacman -S google-chrome pacman -S archlinuxcn-keyring  pacmain -S rofi vim ~/.config/i3/config\n#run rofi bindsym $mod+d exec rofi -show run mod+shift+r 刷新以下  set static ip pacman -S netctl - vim /etc/netctl/ens33-static Description='ens33' Interface=ens33 Connection=ethernet IP=static Address=('192.168.0.14/24') #Routes=('192.168.0.0/24 via 192.168.0.1') Gateway='192.168.0.1' DNS=('192.168.0.1') TimeoutUp=300 TimeoutCarrier=300  wallpaper feh -bg-center Downloads/jpeg vim .xinitrc exec feh -bg-center Downloads/jpeg \u0026amp;  polybar  https://www.cnblogs.com/bluestorm/p/5929478.html https://www.bilibili.com/video/BV1gW411H7Ke/ https://www.yuque.com/sunhl/mvumc2/rq64vb\n ohmysh option https://www.jianshu.com/p/17790d2fc2f6 https://www.jianshu.com/p/d194d29e488c?open_source=weibo_search https://blog.csdn.net/sgzqc/article/details/46627817 # static ip https://github.com/AshNobita/i3andpolybarconfig  ","permalink":"https://6923403.github.io/post/arch_desktop/","tags":["Arch","Linux","i3wm"],"title":"Arch Beautify desktop"},{"categories":null,"contents":"0. Ready work Test environment: Vmware15.5.6pro arch-2020-07.iso You should installed Vmware and download Archlinux iso .\nChange your firmwaretype to UEFI (The way many tutorials did not say)  1. Start ls /sys/firmware/efi/efivars The command detect UEFI files and if your dir not include files your firmwaretype is BIOS .\nThen, ping google.com, detect interent connection\n Archwiki: Note: The installation image has systemd-networkd.service, systemd-resolved.service and iwd.service enabled by default. That will not be the case for the installed system.\n Update systime\ntimedatectl set-ntp true  2. Partition the disks cfdisk /dev/sda #choose gpt Move to Write , enter, yes, last Quit .  3. Format the partitions 3.1 Format:\nmkfs.fat -F32 /dev/sda1 mkswap /dev/sda2 swapon /dev/sda2 mkfs.ext4 /dev/sda3 3.2 Mount the file systems\nmount /dev/sda3 /mnt mkdir -p /mnt/boot/EFI mount /dev/sda1 /mnt/boot/EFI lsblk #check mount  4. Install dev 4.1 According to your country choose your mirror source\nvim /etc/pacman.d/mirrorlist 4.2 install\npacstrap -i /mnt base base-devel linux-lts linux-firmware vi net-tools  5. Configure the system 5.1 Fstab\ngenfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab 5.2 Check your fstab files, like the img\nvim /mnt/etc/fstab  6. System configuration 6.1 Chroot\narch-chroot /mnt 6.2 Time\nln -sf /usr/share/zoneinfo/Region/City /etc/localtime hwclock --systohc --utc 6.3 Localization\nvi /etc/locale.gen #according to your country, choose, del :wq locale-gen locale -a echo LANG=en_US.UTF-8 \u0026gt; /etc/locale.conf locale  ex: #en_US.UTF8 UTF-8 del #: en_US.UTF-8 UTF-8  6.4 hostname\necho hostname \u0026gt; /etc/hostname 6.5 hosts\nvi /etc/hosts 127.0.0.1\tlocalhost ::1\tlocalhost 127.0.0.1 hostname.localdomain hostname 6.6 root password\npasswd  7. install UEFI pacman -S grub efibootmgr grub-install --recheck /dev/sda grub-mkconfig -o /boot/grub/grub.cfg  8. End pacman -S dhcpcd exit umount -R /mnt reboot  Arch Beautify   Reference:\nArch wiki and S.T.BLOG and V2EX\n","permalink":"https://6923403.github.io/post/arch_install/","tags":["Linux","Arch"],"title":"Vmware install Archlinux "},{"categories":null,"contents":"0. Hugo \u0026amp; Markdown Hugo \u0026amp;\u0026amp; MarkDown\n 1. MarkDown template --- title: \u0026quot;{{ replace .Name \u0026quot;-\u0026quot; \u0026quot; \u0026quot; | title }}\u0026quot; date: {{ .Date }} lastmod: {{ .Date }} draft: false tags: [ ] categories: [ ] comment: true ---  2. Hugo command hugo #build html havn't draft=true hugo -D #build html and dragt=true hugo server #Start hugo server  3. Other Reference\n","permalink":"https://6923403.github.io/post/hugomarkdown/","tags":["hugo","markdown"],"title":"Hugo \u0026 Markdown"},{"categories":null,"contents":"0.Ready work Disable BIOS secure boot，choose disable .\n 1. Uninstall old Nvidia drivers sudo apt-get remove --purge nvidia*  2. Add rules vim /etc/modprobe.d/blacklist.conf\n1. blacklist nouveau 2. options nouveau modeset=0  3. Verification After reboot, use the following command no return is successful\nsudo update-initramfs -u lsmod | grep nouveau  4. Choose Navidia drivers version  1.Use command: ubuntu-drivers devices 2.Nvidia Official website  Choose stable version and install\nsudo add-apt-repository ppa:graphics-drivers/ppa sudo apt-get update sudo apt-get install nvidia-driver-***  5. End reboot nvidia-smi Open warehouse =\u0026gt; additional drivers =\u0026gt; choose you drivers .\n","permalink":"https://6923403.github.io/post/install_nvidia/","tags":["linux","drivers","Ubuntu","Nvidia"],"title":"Ubuntu20 Install Nvidia drivers"},{"categories":null,"contents":" void fun(char * fmt, \u0026hellip;); int vsprintf(char *str, const char *format, va_list arg);\n  Test programming #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; /* * Re: https://github.com/antirez/kilo/kilo.c * Re: https://www.runoob.com/cprogramming/c-function-vsprintf.html */ char buffer[80]; int editorSetstatus(const char * fmt, ...) { va_list ap; va_start(ap, fmt); int ret; ret = vsnprintf(buffer, sizeof(buffer - 1), fmt, ap); va_end(ap); return (ret); } int main(int argc, char **argv) { int len = 20; editorSetstatus(\u0026quot;%d\u0026quot;, len); printf(\u0026quot;%s \\n\u0026quot;, buffer); return 0; }  gcc -Wall -g fun.c -o fun\n./fun\nlen = 20\n","permalink":"https://6923403.github.io/post/variable_function/","tags":["CPP","GCC"],"title":"Variable function(fun(char *, ...)) and vsnprintf()"},{"categories":null,"contents":" Boost C++ is Cpp programming language that provides support for tasks and structures\n Download Source https://dl.bintray.com/boostorg/release/1.73.0/source/boost_1_73_0.tar.gz tar zxvf boost(解压)  Set use GCC cd boost ./bootstrap.sh --with-libraries=all --with-toolset=gcc  Compile \u0026amp; Install boost ./b2 toolset=gcc ./b2 install --prefix=/usr  Test programming #include \u0026lt;boost/thread/thread.hpp\u0026gt; //boost thread #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; volatile bool isRuning = true; void func1() { static int cnt1 = 0; while(isRuning) { cout \u0026lt;\u0026lt; \u0026quot;func1:\u0026quot; \u0026lt;\u0026lt; cnt1++ \u0026lt;\u0026lt; endl; sleep(1); } } void func2() { static int cnt2 = 0; while(isRuning) { cout \u0026lt;\u0026lt; \u0026quot;\\tfunc2:\u0026quot; \u0026lt;\u0026lt; cnt2++ \u0026lt;\u0026lt; endl; sleep(2); } } int main() { boost::thread thread1(\u0026amp;func1); boost::thread thread2(\u0026amp;func2); system(\u0026quot;read\u0026quot;); isRuning = false; thread2.join(); thread1.join(); cout \u0026lt;\u0026lt; \u0026quot;exit\u0026quot; \u0026lt;\u0026lt; endl; return 0; } g++ main.cpp -g -o main -lboost_thread -lpthread\n","permalink":"https://6923403.github.io/post/linux_install_boost/","tags":["Boost","Linux","CPP"],"title":"Linux install Boost c++"},{"categories":null,"contents":"Start Download FFmpeg  Install tool 1. install yasm\nsudo apt-get install yasm  if not installed yasm, os will output \u0026ldquo;nasm/yasm not found or too old. Use \u0026ndash;disable-x86asm for a crippled build.\u0026rdquo;\n 2. install SDL2\nSDL2-2.0.12(stable)\ntar -xvf SDL2-2.0.12.tar.gz cd SDL2-2.0.12 ./configure sudo make -j4 sudo make install  Install FFmpeg 1. git clone https://git.ffmpeg.org/ffmpeg.git ffmpeg\ncd ffmpeg/ ./configure sudo make -j4 sudo make install  3. Check ffmpeg -version ffplay -version ","permalink":"https://6923403.github.io/post/ffmpeg_install/","tags":["linux","FFmpeg","Ubuntu"],"title":"Ubuntu20 install FFmpeg"}]