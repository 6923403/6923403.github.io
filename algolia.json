[{"content":"socket struct整理\nhttps://6923403.github.io/post/socket_struct/\n socket编程需要的头文件整理\nhttps://6923403.github.io/post/socket_file/\n exception_class 异常类\nhttps://6923403.github.io/post/cpp_exception/\n Linux Pthread 线程创建与使用\nhttps://6923403.github.io/post/linuxpthread/\n epoll tutorial, epoll处理教程\nhttps://6923403.github.io/post/epoll_use/\n socket function, socket函数\nhttps://6923403.github.io/post/socket/","lvl0":"Socket sum","lvl1":null,"lvl2":"摘要","objectID":"72071327e0729d0deb9b3e157f0c712f","tags":["Socket","CPP","Linux"],"url":"https://6923403.github.io/post/socketsum/"},{"content":"const 作用\n 修饰变量，变量不可以被改变； 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）； 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改； 修饰成员函数，说明该成员函数内不能修改成员变量。   // 类 class A { private: const int a; // 常对象成员，只能在初始化列表赋值 public: // 构造函数 A() : a(0) { }; A(int x) : a(x) { }; // 初始化列表 // const可用于对重载函数的区分 int getValue(); // 普通成员函数 int getValue() const; // 常成员函数，不得修改类中的任何数据成员的值 }; void function() { // 对象 A b; // 普通对象，可以调用全部成员函数、更新常成员变量 const A a; // 常对象，只能调用常成员函数 const A *p = \u0026amp;a; // 指针变量，指向常对象 const A \u0026amp;q = a; // 指向常对象的引用 // 指针 char greeting[] = \u0026quot;Hello\u0026quot;; char* p1 = greeting; // 指针变量，指向字符数组变量 const char* p2 = greeting; // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变） char* const p3 = greeting; // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变） const char* const p4 = greeting; // 自身是常量的指针，指向字符数组常量 } // 函数 void function1(const int Var); // 传递过来的参数在函数内不可变 void function2(const char* Var); // 参数指针所指内容为常量 void function3(char* const Var); // 参数指针为常量 void function4(const int\u0026amp; Var); // 引用参数在函数内为常量 // 函数返回值 const int function5(); // 返回一个常数 const int* function6(); // 返回一个指向常量的指针变量，使用：const int *p = function6(); int* const function7(); // 返回一个指向变量的常指针，使用：int* const p = function7();  const 的指针与引用  指针  指向常量的指针（pointer to const） 自身是常量的指针（常量指针，const pointer）   引用  指向常量的引用（reference to const） 没有 const reference，因为引用本身就是 const pointer     用法小结 指针","lvl0":"CPP_Const","lvl1":null,"lvl2":"摘要","objectID":"638dfd340c3f35cb53a639b7dd0f83dc","tags":["CPP","Const","Pointer"],"url":"https://6923403.github.io/post/cppconst/"},{"content":"什么是C/S和B/S架构？\nC/S架构 软件（即客户机/服务器模式）分为客户机和服务器两层：第一层是在客户机系统上结合了表示与业务逻辑，第二层是通过网络结合了数据库服务器。 简单的说就是第一层是用户表示层，第二层是数据库层。 客户端和服务器直接相连，这两个组成部分都承担着重要的角色。\nB/S架构 第一层是浏览器（即客户端）只有简单的输入输出功能，处理极少部分的事务逻辑。由于客户不需要安装客户端，只要有浏览器就能上网浏览，所以它面向的是大范围的用户，所以界面设计得比较简单，通用。\n第二层是WEB服务器，扮演着信息传送的角色。当用户想要访问数据库时，就会首先向WEB服务器发送请求，WEB服务器统一请求后会向数据库服务器发送访问数据库的请求，这个请求是以SQL语句实现的。\n第三层是数据库服务器，它存放着大量的数据。当数据库服务器收到了WEB服务器的请求后，会对SQL语句进行处理，并将返回的结果发送给WEB服务器，接下来，WEB服务器将收到的数据结果转换为HTML文本形式发送给浏览器。\n 优点/缺点 C/S架构的优点\na. 客户端和服务器直接相连。点对点的连接方式更安全，可以直接操作本地文本，比较方便。\nb. 客户端可以处理一些逻辑事务。可以进行数据处理和数据存储，提供一定的帮助。\nc. 客户端直接操作界面。\nC/S架构的缺点\na\u0026gt; C/S架构适用于局域网，对网速的要求比较高。\nb\u0026gt; 客户端界面缺乏通用性，且当业务更改时就需要更改界面，重新编写。\nc\u0026gt; 随着用户数量的增多，会出现通信拥堵、服务器响应速度慢等情况。\nd\u0026gt; 系统的维护也比较麻烦。\n B/S架构的优点  a\u0026gt; 浏览器和数据库服务器采用多对多的方式连接。因此适合在广域网里实现巨大的互联网，甚至是全球网，有着很强大的信息共享性。\nb\u0026gt; 浏览器只处理一些简单的逻辑事务，负担小。\nc\u0026gt; 数据都集中存放在数据库服务器，所以不存在数据不一致现象。\nd\u0026gt; 随着服务器负载的增加，可以平滑地增加服务器的个数并建立集群服务器系统，然后在各个服务器之间做负载均衡。\ne\u0026gt; B/S建立在广域网上，所以需要的网速要求不高。\nf\u0026gt; 不需要安装客户端，只要能连上网，就能随时随地的浏览页面。\ng\u0026gt; 能有效地保护数据平台和管理访问权限，确保服务器数据库的数据安全。\nB/S架构的缺点  a\u0026gt; 服务器承担着重要的责任，数据负荷较重。一旦发生服务器“崩溃”等问题，后果不堪设想。\nb\u0026gt; 页面需要不断地动态刷新，当用户增多时，网速会变慢。\n  第一层是浏览器（即客户端）只有简单的输入输出功能，处理极少部分的事务逻辑。由于客户不需要安装客户端，只要有浏览器就能上网浏览，所以它面向的是大范围的用户，所以界面设计得比较简单，通用。 第二层是WEB服务器，扮演着信息传送的角色。当用户想要访问数据库时，就会首先向WEB服务器发送请求，WEB服务器统一请求后会向数据库服务器发送访问数据库的请求，这个请求是以SQL语句实现的。 第三层是数据库服务器，它存放着大量的数据。当数据库服务器收到了WEB服务器的请求后，会对SQL语句进行处理，并将返回的结果发送给WEB服务器，接下来，WEB服务器将收到的数据结果转换为HTML文本形式发送给浏览器。   https://blog.csdn.net/qq_42828949/article/details/82822901\nhttps://blog.csdn.net/zhengqijun_/article/details/53056624","lvl0":"C/S_B/S 架构","lvl1":null,"lvl2":"摘要","objectID":"7de9a9ee891bb2628fa26a80d1870b4b","tags":["Linux","TCP"],"url":"https://6923403.github.io/post/cs_bs/"},{"content":"O(1)常数阶 \u0026lt; O(logn)对数阶 \u0026lt; O(n)线性阶 \u0026lt; O(n^2)平方阶 \u0026lt; O(n^3)(立方阶) \u0026lt; O(2^n) (指数阶)\nFor O(n) int function1(int x, int n) { int result = 1; // 注意 任何数的0次方等于1 for (int i = 0; i \u0026lt; n; i++) { result = result * x; } return result; }  Recursion O(n) int function2(int x, int n) { if (n == 0) { return 1; // return 1 同样是因为0次方是等于1的 } return function2(x, n - 1) * x; }  Recursion2 O(n) int function3(int x, int n) { if (n == 0) { return 1; } if (n % 2 == 1) { return function3(x, n/2) * function3(x, n/2)*x; } return function3(x, n/2) * function3(x, n/2); }  Recursion3 O(logn) int function4(int x, int n) { if (n == 0) { return 1; } int t = function4(x, n/2);// 这里相对于function3，是把这个递归操作抽取出来 if (n % 2 == 1) { return t*t*x; } return t*t; } ","lvl0":"Algorithm x^n","lvl1":null,"lvl2":"摘要","objectID":"3ac4bdf6385acc5e5b2b6d44b89aa411","tags":["Algorithm","CPP","Recursion"],"url":"https://6923403.github.io/post/recursion/"},{"content":"#include \u0026lt;pthread.h\u0026gt; int pthread_condattr_init(pthread_condattr_t* attr); int pthread_condattr_destroy(pthread_condattr_t* attr); //返回值：成功返回0；失败返回错误编码 pthread_condattr_init\n 功能：对条件变量属性结构体初始化 调用此函数之后，条件变量属性结构体的属性都是系统默认值，如果想要设置其他属性，还需要调用不同的函数进行设置  pthread_condattr_destroy\n 功能：对条件变量属性结构体反初始化（销毁） 只反初始化，不释放内存  Re:\nhttps://blog.csdn.net/qq_41453285/article/details/90904870\n #include \u0026lt;pthread.h\u0026gt; int pthread_condattr_setshared(pthread_condattr_t* attr,int pshared); int pthread_condattr_getshared(const pthread_condattr_t* restrict attr,int* restrict pshared); //返回值：成功返回0；失败返回错误编码 pthread_condattr_setshared\n 功能：设置条件变量的进程共享属性  pthread_condattr_getshared\n 功能：获取条件变量的进程共享属性  Re:\nhttps://blog.csdn.net/qq_41453285/article/details/90904870\n #include \u0026lt;pthread.h\u0026gt; int pthread_condattr_setclock(pthread_condattr_t* attr,clockid_t clock_id); int pthread_condattr_getclock(const pthread_condattr_t* restrict attr,clockid_t *restrict clock_id); //返回值：成功返回0；失败返回错误编码 pthread_condattr_setclock\n 功能：此函数用于设置pthread_cond_timewait函数使用的时钟ID  pthread_condattr_getclock\n 功能：此函数获取可被用于pthread_cond_timedwait函数的时钟ID。pthread_cond_timedwait函数使用前需要用pthread_condattr_t对条件变量进行初始化  Re:","lvl0":"Linux Pthread","lvl1":null,"lvl2":"摘要","objectID":"abf9fadd762eac2c374bc3d8b42ee423","tags":["Linux","Pthread","CPP"],"url":"https://6923403.github.io/post/linuxpthread/"},{"content":"class derived-class: access-specifier base-class\nclass Shape { public: void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // 派生类 class Rectangle: public Shape { public: int getArea() { return (width * height); } }; Rectangle rect; rect.setWidth(3); rect.setHeight(5); #rect result = 15 cout \u0026lt;\u0026lt; rect.getArea() \u0026lt;\u0026lt; endl;  访问控制和继承\n   访问 public protected private     同一个类 yes yes yes   派生类 yes yes no   外部的类 yes no no     公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。 保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。 私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。  ","lvl0":"Cpp_inherit","lvl1":null,"lvl2":"摘要","objectID":"7b278df00c7c2e10405b5f8e4ce2be4e","tags":["CPP"],"url":"https://6923403.github.io/post/cpp_inherit/"},{"content":"Mysql ex     mysql_init() 获取或初始化MYSQL结构   mysql_real_connect() 连接到MySQL服务器。   mysql_query() 执行指定为“以Null终结的字符串”的SQL查询   mysql_use_result() 初始化逐行的结果集检索   mysql_field_count() 返回上次执行语句的结果集的列数   mysql_fetch_row() 从结果集中获取下一行   mysql_num_fields() 返回结果集中的字段数     class MyDB { public: MyDB(); ~MyDB(); bool initDB(string host, string user, string pwd, string db_name); bool exeSQL(string sql); private: MYSQL *connection; MYSQL_RES *result; MYSQL_ROW row; };  基本步骤\n使用mysql_init()初始化连接 使用mysql_real_connect()建立一个到mysql数据库的连接 使用mysql_query()执行查询语句 result = mysql_use_result(conn)获取结果集 mysql_field_count(conn)获取查询的列数，mysql_num_fields(result)获取结果集的字段数 通过mysql_fetch_row(result)不断获取下一行，然后循环输出 释放结果集所占内存mysql_free_result(result) mysql_close(conn)关闭连接  Re:","lvl0":"CPP_Mysql_use","lvl1":null,"lvl2":"摘要","objectID":"aecdfca1c35844aeaec11c4506770ea7","tags":["Mysql","CPP","Linux"],"url":"https://6923403.github.io/post/mysql_use/"},{"content":"Configure the package management system (yum) vim /etc/yum.repos.d/mongodb-org-4.4.repo\n[mongodb-org-4.4] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.4/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-4.4.asc  Install Mongodb sudo yum install -y mongodb-org  Directory Paths sudo mkdir -p /var/lib/mongo sudo mkdir -p /var/log/mongodb sudo chown -R mongod:mongod /var/lib/mongo sudo chown -R mongod:mongod /var/log/mongodb Start mongodb sudo systemctl start mongod sudo systemctl status mongod sudo systemctl enable mongod mongo //use  Re:\nhttps://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/","lvl0":"Centos7 Install mongodb","lvl1":null,"lvl2":"摘要","objectID":"02f69c70c7c4659c3ebb49197470d67a","tags":["Linux","Mongodb"],"url":"https://6923403.github.io/post/install_mongodb/"},{"content":"升级GCC yum -y install centos-release-scl yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils scl enable devtoolset-9 bash echo \u0026quot;source /opt/rh/devtoolset-9/enable\u0026quot; \u0026gt;\u0026gt; /etc/profile gcc -v  安装redis wget http://download.redis.io/releases/redis-6.0.8.tar.gz tar -xvf redis-6.0.8/tar/gz cd redis make -j4 make install PREFIX=/usr/local/redis  配置redis cd redis cp redis.conf /usr/local/redis/bin/ vim /usr/local/redis/bin/redis.conf\ndaemonize no 改为 daemonize yes  开机自启 vim /etc/systemd/system/redis.service\n[Unit] Description=redis-server After=network.target [Service] Type=forking ExecStart=/usr/local/redis/bin/redis-server /usr/local/redis/bin/redis.conf PrivateTmp=true [Install] WantedBy=multi-user.target systemctl daemon-reload ln -s /usr/local/redis/bin/redis-cli /usr/bin/redis systemctl start redis.","lvl0":"Centos7 Install_redis","lvl1":null,"lvl2":"摘要","objectID":"8e036d949b5614a2d382271fbb18ccf3","tags":["Linux","Redis"],"url":"https://6923403.github.io/post/install_redis/"},{"content":"1.添加Mysql5.7仓库 sudo rpm -ivh https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm\n2.确认Mysql仓库成功添加 sudo yum repolist all | grep mysql | grep enabled\n3.安装Mysql5.7 sudo yum -y install mysql-community-server\n4.启动Mysql sudo systemctl start mysqld\n5.设置系统启动时自动启动 sudo systemctl enable mysqld\n6.查看启动状态 sudo systemctl status mysqld\n7.root 密码 cat /var/log/mysqld.log | grep -i 'temporary password'\n8.执行下面命令进行安全设置 这个命令会进行设置root密码设置，移除匿名用户，禁止root用户远程连接等\nmysql_secure_installation\n9.设置数据库编码为utf8 sudo vim /etc/my.cnf\n[client] default-character-set=utf8 [mysql] default-character-set=utf8 [mysqld] collation-server = utf8_unicode_ci init-connect='SET NAMES utf8' character-set-server = utf8 reboot sudo systemctl restart mysqld","lvl0":"Centos7 Install mysql","lvl1":null,"lvl2":"摘要","objectID":"0e47424ee6ec868d45f1c28a3d8ec552","tags":["Mysql","Linux"],"url":"https://6923403.github.io/post/install_mysql/"},{"content":"#include \u0026lt;unistd.h\u0026gt; int getopt(int argc, char * const argv[], const char *optstring); extern char *optarg; extern int optind, opterr, optopt; #include \u0026lt;getopt.h\u0026gt; int getopt_long(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex); int getopt_long_only(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex);  static struct option Vcopts[] = { {\u0026quot;device\u0026quot;, required_argument, NULL, 'd'}, {\u0026quot;savefile\u0026quot;, optional_argument, NULL, 'f'}, {\u0026quot;help\u0026quot;, no_argument, NULL, 'h'}, {\u0026quot;version\u0026quot;, no_argument, NULL, 'v'}, {\u0026quot;Device list\u0026quot;, no_argument, NULL, 'l'}, {\u0026quot;http-proxy\u0026quot;, required_argument, \u0026amp;lopt, 1}, {0, 0, 0, 0} };  no_argument: -h --h, -v --v required_argument: -d/ -d ens33/ -d = ens33 optional_argument: -f filename/ -f = filename \u0026amp;lopt: \u0026ndash;http-proxy=127.","lvl0":"getopt_long","lvl1":null,"lvl2":"摘要","objectID":"8ced399bc2ac8507088b42c4b6eeaed7","tags":["Linux","CPP"],"url":"https://6923403.github.io/post/getopt_long/"},{"content":"创建数据库 CREATE DATABASE IF NOT EXISTS vctest DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 2. CREATE DATABASE IF NOT EXISTS mytestdb;\n删除数据库 drop database test1; 2. DROP DATABASE IF EXISTS mytestdb;\n查看All DB show databases;\n导入sql source test.sql\n select\nuse vctest select city, phone, country from `offices`; SELECT语句由以下列表中所述的几个子句组成：\n语句中的SELECT和FROM语句是必须的，其他部分是可选的。\n SELECT之后是逗号分隔列或星号(*)的列表，表示要返回所有列。 FROM指定要查询数据的表或视图。 JOIN根据某些连接条件从其他表中获取数据。 WHERE过滤结果集中的行。 GROUP BY将一组行组合成小分组，并对每个小分组应用聚合函数。 HAVING过滤器基于GROUP BY子句定义的小分组。 ORDER BY指定用于排序的列的列表。 LIMIT限制返回行的数量。  即使WHERE子句出现在语句的末尾，但MySQL会首先使用WHERE子句中的表达式来选择匹配的行。\nSELECT lastname, firstname, jobtitle FROM employees WHERE jobtitle = 'Sales Rep';  INSERT 创建表","lvl0":"Mysql_use","lvl1":null,"lvl2":"摘要","objectID":"1700588a7cc1b688481294d75377f8d2","tags":["Mysql","Linux"],"url":"https://6923403.github.io/post/mysqluse/"},{"content":"形参（形式参数）\n在函数定义中出现的参数可以看做是一个占位符，它没有数据，只能等到函数被调用时接收传递进来的数据，所以称为形式参数，简称形参。\n实参（实际参数）\n函数被调用时给出的参数包含了实实在在的数据，会被函数内部的代码使用，所以称为实际参数，简称实参。\n形参和实参的功能是传递数据，发生函数调用时，实参的值会传递给形参。\n Re: http://c.biancheng.net/view/1853.html   左值和右值\nhttp://c.biancheng.net/view/1510.html\n 常量和变量\nhttps://www.runoob.com/cprogramming/c-variables.html\nhttps://www.runoob.com/cprogramming/c-constants.html\nhttp://c.biancheng.net/cpp/html/19.html","lvl0":"Left_Right","lvl1":null,"lvl2":"摘要","objectID":"84d0d2ffc0a2d9f7429f5694b1567e89","tags":["CPP"],"url":"https://6923403.github.io/post/leftright/"},{"content":"https://zhuanlan.zhihu.com/p/33074506\nhttps://www.runoob.com/w3cnote/c-volatile-keyword.html","lvl0":"About function: Volatile","lvl1":null,"lvl2":"摘要","objectID":"ef9fa4ecc937ba8f7ec7ccc9facfa5bc","tags":["CPP","Volatile"],"url":"https://6923403.github.io/post/volatile/"},{"content":"struct sockaddr { unsigned short sa_family; /* address family, AF_xxx */ char sa_data[14]; /* 14 bytes of protocol address */ }; 此数据结构用做bind、connect、recvfrom、sendto等函数的参数，指明地址信息。\n 但一般编程中并不直接针对此数据结构操作，而是使用另一个与sockaddr等价的数据结构sockaddr_in（在netinet/in.h中定义）：\nstruct sockaddr_in { short int sin_family; /* Address family */ unsigned short int sin_port; /* Port number */ struct in_addr sin_addr; /* Internet address */ unsigned char sin_zero[8]; /* Same size as struct sockaddr */ }; 在编程中大多数是使用sockaddr_in这个结构来设置/获取地址信息\n  sin_family指代协议族，在socket编程中只能是AF_INET\n  sin_port存储端口号（使用网络字节顺序）\n  sin_addr存储IP地址，使用in_addr这个数据结构","lvl0":"Socket struct","lvl1":null,"lvl2":"摘要","objectID":"0b3e439e0e5e761a813b01c8c54ff61e","tags":["Sokcet","Linux","CPP"],"url":"https://6923403.github.io/post/socket_struct/"},{"content":"socket编程中需要用到的头文件\n  sys/types.h：数据类型定义\n  sys/socket.h：提供socket函数及数据结构\n  netinet/in.h：定义数据结构sockaddr_in\n  arpa/inet.h：提供IP地址转换函数\n  netdb.h：提供设置及获取域名的函数\n  sys/ioctl.h：提供对I/O控制的函数\n  sys/poll.h：提供socket等待测试机制的函数\n   其他在网络程序中常见的头文件\n  unistd.h：提供通用的文件、目录、程序及进程操作的函数\n  errno.h：提供错误号errno的定义，用于错误处理\n  fcntl.h：提供对文件控制的函数\n  time.h：提供有关时间的函数\n  crypt.h：提供使用DES加密算法的加密函数\n  pwd.h：提供对/etc/passwd文件访问的函数\n  shadow.h：提供对/etc/shadow文件访问的函数\n  pthread.h：提供多线程操作的函数\n  signal.h：提供对信号操作的函数\n  sys/wait.h、sys/ipc.h、sys/shm.h：提供进程等待、进程间通讯（IPC）及共享内存的函数\n   建议：在编写网络程序时，可以直接使用下面这段头文件代码\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netdb.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.","lvl0":"Socket file","lvl1":null,"lvl2":"摘要","objectID":"39275934d4aaf4e341ef93c52f11e16d","tags":["Socket","Linux","CPP"],"url":"https://6923403.github.io/post/socket_file/"},{"content":"class exception{ public: exception () throw(); //构造函数 exception (const exception\u0026amp;) throw(); //拷贝构造函数 exception\u0026amp; operator= (const exception\u0026amp;) throw(); //运算符重载 virtual ~exception() throw(); //虚析构函数 virtual const char* what() const throw(); //虚函数 } what() 函数返回一个能识别异常的字符串，正如它的名字“what”一样，可以粗略地告诉你这是什么异常。\n exception 类的继承层次:  exception 类 直接派生类\n   exceptopn explain     login_error logic error   runtime_error 运行时错误   bad_alloc 使用 new 或 new[] 分配内存失败时抛出的异常   bad_typeid 使用 typeid 操作一个 NULL 指针，而且该指针是带有虚函数的类，这时抛出 bad_typeid 异常   bad_cast 使用 dynamic_cast 转换失败时抛出的异常   ios_base::failure io 过程中出现的异常   bad_exception 这是个特殊的异常，如果函数的异常列表里声明了 bad_exception 异常，当函数内部抛出了异常列表中没有的异常时，如果调用的 unexpected() 函数中抛出了异常，不论什么类型，都会被替换为 bad_exception 类型     logic_error 的派生类","lvl0":"Cpp exception class","lvl1":null,"lvl2":"摘要","objectID":"ab8fb604bdd54812ed0276038ac0d125","tags":["CPP","Linux","exception"],"url":"https://6923403.github.io/post/cpp_exception/"},{"content":"获取Backtrace #include \u0026lt;execinfo.h\u0026gt; /* Store up to SIZE return address of the current program state in ARRAY and return the exact number of values stored. */ int backtrace(void **array, int size); /* Return names of functions from the backtrace list in ARRAY in a newly malloc()ed memory block. */ char **backtrace_symbols(void *const *array, int size); /* This function is similar to backtrace_symbols() but it writes the result immediately to a file.","lvl0":"Linux cpp put Backtrace","lvl1":null,"lvl2":"摘要","objectID":"0b5aab4972ea69f22d3cb165c7465945","tags":["Linux","CPP","Backtrace"],"url":"https://6923403.github.io/post/backtrace/"},{"content":"#include \u0026lt;iostream\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; int main() { std::string str = \u0026quot;Hello\u0026quot;; std::vector\u0026lt;std::string\u0026gt; v; //调用常规的拷贝构造函数，新建字符数组，拷贝数据 v.push_back(str); std::cout \u0026lt;\u0026lt; \u0026quot;After copy, str is \\\u0026quot;\u0026quot; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026quot;\\\u0026quot;\\n\u0026quot;; //调用移动构造函数，掏空str，掏空后，最好不要使用str v.push_back(std::move(str)); std::cout \u0026lt;\u0026lt; \u0026quot;After move, str is \\\u0026quot;\u0026quot; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026quot;\\\u0026quot;\\n\u0026quot;; std::cout \u0026lt;\u0026lt; \u0026quot;The contents of the vector are \\\u0026quot;\u0026quot; \u0026lt;\u0026lt; v[0] \u0026lt;\u0026lt; \u0026quot;\\\u0026quot;, \\\u0026quot;\u0026quot; \u0026lt;\u0026lt; v[1] \u0026lt;\u0026lt; \u0026quot;\\\u0026quot;\\n\u0026quot;; } Cout:\nAfter copy, str is \u0026quot;Hello\u0026quot; After move, str is \u0026quot;\u0026quot; The contents of the vector are \u0026quot;Hello\u0026quot;, \u0026quot;Hello\u0026quot;  函数原型 template \u0026lt;typename T\u0026gt; typename remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp; move(T\u0026amp;\u0026amp; t) { return static_cast\u0026lt;typename remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp;\u0026gt;(t); }  原型定义中的原理实现: 公式一）X\u0026amp; \u0026amp;、X\u0026amp;\u0026amp; \u0026amp;、X\u0026amp; \u0026amp;\u0026amp;都折叠成X\u0026amp;，用于处理左值","lvl0":"Cpp11 move","lvl1":null,"lvl2":"摘要","objectID":"6212f19c7456351f46fad3b62187446f","tags":["CPP","Liux","move"],"url":"https://6923403.github.io/post/move/"},{"content":"create_thread Ex   1.导入#include\u0026mdash;用于创建线程\n  2.导入#include\u0026ndash;用于时间延时 获取时间之类的\n  定义一个线程对象t1，这就自动创建了一个线程，参数就是你要线程去执行的函数，t1是变量名字 随便取\nstd::thread t1(func);\n下面这里返回一个毫秒级别的时间间隔参数值，间隔10毫秒\nstd::chrono::milliseconds(10) this_thread::sleep_for（）就是让此线程休眠，可以传入休眠的时间 this_thread::sleep_for(std::chrono::milliseconds(10));让本线程休眠10毫秒  thread4\n join()就是阻塞线程 阻塞的目的就是让Main主线程等待一下创建的线程，免得我函数还在跑，程序就直接结束了。 detach()将线程与线程对象分离   thread5\nc++11还提供了一个lock_guard类，它利用了RAII机制可以保证安全释放mutex。\n在std::lock_guard对象构造时，传入的mutex对象(即它所管理的mutex对象)会被当前线程锁住。\n在lock_guard对象被析构时，它所管理的mutex对象会自动解锁，不需要程序员手动调用lock和unlock对mutex进行上锁和解锁操作。\nlock_guard对象并不负责管理mutex对象的生命周期，lock_guard对象只是简化了mutex对象的上锁和解锁操作，方便线程对互斥量上锁，即在某个lock_guard对象的生命周期内，它所管理的锁对象会一直保持上锁状态；\n而lock_guard的生命周期结束之后，它所管理的锁对象会被解锁。程序员可以非常方便地使用lock_guard，而不用担心异常安全问题。\n thread6\nc++11还提供了std::unique_lock\n类 unique_lock 是通用互斥包装器，允许延迟锁定、锁定的有时限尝试、递归锁定、所有权转移和与条件变量一同使用。 unique_lock比lock_guard使用更加灵活，功能更加强大。 使用unique_lock需要付出更多的时间、性能成本。  thread7\n互斥量很像的条件变量的知识\n条件变量std::condition_variable的使用 std::condition_variable 是为了解决死锁而生的。 当互斥操作不够用而引入的。\n比如，线程可能需要等待某个条件为真才能继续执行，而一个忙等待循环中可能会导致所有其他线程都无法进入临界区使得条件为真时，就会发生死锁。所以，condition_variable实例被创建出现主要就是用于唤醒等待线程从而避免死锁。\nstd::condition_variable:\n notify_one()用于唤醒一个线程； notify_all() 则是通知所有线程。  C++11中的std::condition_variable就像Linux下使用pthread_cond_wait和pthread_cond_signal一样，可以让线程休眠，直到被唤醒，现在在从新执行。线程等待在多线程编程中使用非常频繁，经常需要等待一些异步执行的条件的返回结果。\n thread8\n原子变量的使用\n在新标准C++11，引入了原子操作的概念，原子操作更接近内核，并通过这个新的头文件提供了多种原子操作数据类型.\n例如，atomic_bool,atomic_int等等，如果我们在多个线程中对这些类型的共享资源进行操作，编译器将保证这些操作都是原子性的，也就是说，确保任意时刻只有一个线程对这个资源进行访问，编译器将保证，多个线程访问这个共享资源的正确性。从而避免了锁的使用，提高了效率。\n thread9\nfuture与promise的使用\n在c++11中增加的线程库很方便的让我们去使用线程，但是因为做出了一些改变，我们并不能像往常一样直接使用thread.join()获取线程函数的返回值了，而我们有时候又确实要利用线程函数的返回值。\nthread库提供了future用来访问异步操作的结果，因为一个异步操作的结果往往不能立即获取，只能在未来的某个时候从某个地方获取，这个异步操作的结果是一个未来的期待值，所以被称为future .\n future和promise的作用是在不同线程之间传递数据。\n 假设线程1需要线程2的数据，那么组合使用方式如下:","lvl0":"CPP11_thread","lvl1":null,"lvl2":"摘要","objectID":"7503fe0a87a6b4802fbecd373a445039","tags":["CPP","thread"],"url":"https://6923403.github.io/post/cppthread/"},{"content":"epoll是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。\nepoll除了提供select/poll那种IO事件的水平触发（Level Triggered）外，还提供了边缘触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。\n  水平触发（LT）：默认工作模式，即当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序可以不立即处理该事件；下次调用epoll_wait时，会再次通知此事件\n  边缘触发（ET）： 当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次通知此事件。（直到你做了某些操作导致该描述符变成未就绪状态了，也就是说边缘触发只在状态由未就绪变为就绪时只通知一次）。\n   #include \u0026lt;sys/epoll.h\u0026gt; epoll与select Epoll 没有最大并发连接的限制，上限是最大可以打开文件的数目 效率提升，epoll对于句柄事件的选择不是遍历的，是事件响应的，就是句柄上事件来就马上选择出来，不需要遍历整个句柄链表，因此效率非常高，内核将句柄用红黑树保存的，IO效率不随FD数目增加而线性下降。 内存拷贝， select让内核把 FD 消息通知给用户空间的时候使用了内存拷贝的方式，开销较大，但是Epoll 在这点上使用了共享内存的方式，这个内存拷贝也省略了。 相比于select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。因为在内核中的select实现中，它是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。 并且，在linux/posix_types.h头文件有这样的声明： #define __FD_SETSIZE 1024 表示select最多同时监听1024个fd，当然，可以通过修改头文件再重编译内核来扩大这个数目，但这似乎并不治本。\n epoll_create int epoll_create(int size); 创建一个epoll的句柄，\nsize用来告诉内核这个监听的数目一共有多大。 这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。\n epoll_ctl int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); epoll_ctl(_iEpollfd, op, fd, \u0026amp;ev); //Error:_iEpollfd: -1. Success: _iEpollfd = fd epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型\nEPOLL_CTL_ADD 注册新的fd到epfd中； EPOLL_CTL_MOD 修改已经注册的fd的监听事件； EPOLL_CTL_DEL 从epfd中删除一个fd；\nfd 是要监听的fd","lvl0":"epoll use","lvl1":null,"lvl2":"摘要","objectID":"1fc768c0612503f5143aef07e6208b53","tags":["Linux","Socket","CPP"],"url":"https://6923403.github.io/post/epoll_use/"},{"content":"setsockopt\n获取或者设置与某个套接字关联的选 项。选项可能存在于多层协议中，它们总会出现在最上面的套接字层。当操作套接字选项时， 选项位于的层和选项的名称必须给出。为了操作套接字层的选项，应该 将层的值指定为SOL_SOCKET。为了操作其它层的选项，控制选 项的合适协议号必须给出。例如，为了表示一个选项由TCP协议解析，层应该设定为协议 号TCP。 SO_LINGER选项\nstruct linger { int l_onoff; int l_linger; }; Re: https://segmentfault.com/a/1190000019360464\nhttps://www.cnblogs.com/eeexu123/p/5275783.html\n epoll_ctl(_iEpollfd, op, fd, \u0026amp;ev); //Error:_iEpollfd: -1. Success: _iEpollfd = fd\n int fcntl(int fd, int cmd); int fcntl(int fd, int cmd, long arg); int fcntl(int fd, int cmd, struct flock *lock); fcntl函数有5种功能：\n 1.复制一个现有的描述符（cmd=F_DUPFD）. 2.获得／设置文件描述符标记(cmd=F_GETFD或F_SETFD). 3.获得／设置文件状态标记(cmd=F_GETFL或F_SETFL). 4.获得／设置异步I/O所有权(cmd=F_GETOWN或F_SETOWN). 5.获得／设置记录锁(cmd=F_GETLK,F_SETLK或F_SETLKW).  Re: https://www.cnblogs.com/xuyh/p/3273082.html\n 非阻塞I/O使我们的操作要么成功，要么立即返回错误，不被阻塞。\n对于一个给定的描述符两种方法对其指定非阻塞I/O:\n 1.调用open获得描述符，并指定O_NONBLOCK标志 2.对已经打开的文件描述符，调用fcntl，打开O_NONBLOCK文件状态标志。  flags = fcntl( s, F_GETFL, 0 ) ) fcntl( s, F_SETFL, flags | O_NONBLOCK ) Re: https://blog.","lvl0":"Socket function","lvl1":null,"lvl2":"摘要","objectID":"d3212cdcb56a3aa9454cb7d589b22b1d","tags":["Linux","CPP","Socket"],"url":"https://6923403.github.io/post/socket/"},{"content":"Install docker apt-get remove docker docker-engine docker.io containerd runc curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - apt-key fingerprint 0EBF**** add-apt-repository \\ \u0026quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ bionic \\ stable\u0026quot; apt-get install docker-ce docker-ce-cli containerd.io # https://www.daocloud.io/mirror curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io docker run hello-world  Compose https://gitee.com/xipushi/dockercompose.git chmod +x docker-compose-Linux-x86_64 mv docker-compose-Linux-x86_64 docker-compose cp /use/local/bin docker-compose --version  Dockerfile # from based nginx # run start FROM nginx # exec: RUN[\u0026quot;.","lvl0":"Docker use Tutorial","lvl1":null,"lvl2":"摘要","objectID":"c4f4161c6ebd24638dd5a22e1119415d","tags":["Linux","Docker"],"url":"https://6923403.github.io/post/docker_tutorial/"},{"content":"V1  ############ 交叉编译 CROSS_COMPILE=aarch64-himix100-linux- CC=$(CROSS_COMPILE)g++ # 当前路径 PWD := $(shell pwd) #库 LIB += -lpthread -lsqlite3 #参数 CFLAG= -D_GNU_SOURCE -D__USE_XOPEN -g #.cpp源文件 SRCS=$(wildcard ./src/*.cpp) #头文件 INC=-I$(PWD)/include #中间文件 OBJS=$(SRCS:.cpp=.o) #二进制文件 BIN=maincpp #start，表示开始执行 start:$(OBJS) $(CC) -o $(BIN) $(OBJS) $(CFLAG) $(LIB) .cpp.o: $(CC) $(INC) -o $@ -c $\u0026lt; $(CFLAB) $(LIB) .PHONY : clean clean: rm -f ${BIN} ./src/*.o  V2 # Makefile cc=gcc LDFLAGS=-lncurses SRCS := $(wildcard *.c) TARGET := $(SRCS:%.c=%) $(TARGET):$(SRCS) $(cc) $(LDFLAGS) $(SRCS) -o $(TARGET) clean: rm $(TARGET)  Reference: Makefile 文件 -只有include和src文件夹","lvl0":"Makefile template","lvl1":null,"lvl2":"摘要","objectID":"cfef4b94eb8ab81888ac109ec5989c62","tags":["CPP","Linux","Makefile"],"url":"https://6923403.github.io/post/makefile_template/"},{"content":"性质1:在二叉树的第i层上至多有2 i-1 个结点(i≥1)。\n  性质2:深度为k的二叉树至多有2 k -1个结点(k≥1)。\n  性质3:对任何一棵二叉树T,如果其终端结点数为n 0 ,度为2的结点数 为n 2 ,则n 0 =n 2 +1。\n  性质4:具有n个结点的完全二叉树的深度为|log 2 n+1|(|x|表示不大于x 的最大整数)。\n  性质5:如果对一棵有n个结点的完全二叉树(其深度为)的结点按层序 编号(从第1层到第层,每层从左到右),对任一结点i(1≤i≤n)有:\n   1.如果i=1,则结点i是二叉树的根,无双亲;如果i\u0026gt;1,则其双亲是结 点。\n  2.如果2i\u0026gt;n,则结点i无左孩子(结点i为叶子结点);否则其左孩子是 结点2i。\n  3.如果2i+1\u0026gt;n,则结点i无右孩子;否则其右孩子是结点2i+1。\n  树转换为二叉树 将树转换为二叉树的步骤如下\n  1.加线。在所有兄弟结点之间加一条连 线。\n  2.去线。对树中每个结点,只保留它与第一个孩子结点的连线,删 除它与其他孩子结点之间的连线。\n  3.层次调整。以树的根结点为轴心, 将整棵树顺时针旋转一定的角度,使之结构层次分明。注意第一个孩子 是二叉树结点的左孩子,兄弟转换过来的孩子是结点的右孩子\n   森林转换为二叉树 森林是由若干棵树组成的,所以完全可以理解为,森林中的每一棵树都是兄弟,可以按照兄弟的处理办法来操作 .\n 1.把每个树转换为二叉树。 2.第一棵二叉树不动,从第二棵二叉树开始,依次把后一棵 二叉树的根结点作为前一棵二叉树的根结点的右孩子,用线连接起来。 当所有的二叉树连接起来后就得到了由森林转换来的二叉树。   二叉树转换为树 二叉树转换为树是树转换为二叉树的逆过程,也就是反过来做而已。","lvl0":"Binary Tree","lvl1":null,"lvl2":"摘要","objectID":"bc2a21d4190b1d325560573172dc2a1a","tags":["CPP","Algorithm","DataStruct","BinaryTree"],"url":"https://6923403.github.io/post/binart_tree/"},{"content":"Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。 Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。   1.shared_ptr shared_ptr\u0026lt;T\u0026gt; sp\n多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。\n 支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁   3. make_shared make_shared\u0026lt;T\u0026gt;(args)\nshared_ptr\u0026lt;int\u0026gt; p = make_shared\u0026lt;int\u0026gt;(42); 返回一个shared_ptr, 指向一个动态分配的类型为T的对象。使用args初始化此对象\n 3.weak_ptr weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。\n 可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题   4.","lvl0":"C++ auto ponit","lvl1":null,"lvl2":"摘要","objectID":"0a5eaa2d9d4827bfc47c8e7baa93a86b","tags":["CPP","point"],"url":"https://6923403.github.io/post/cpp_auto_ponit/"},{"content":"0.Array int url[10]; //true int url[6 + 4] //true int len = 10; int url[len] //flase  1.Constexpr #include \u0026lt;iostream\u0026gt; using namespace std; int main() { /* * If have not constexpr, CPP throw error */ constexpr int num = 1 + 2 + 3; int url[num] = {1,2,3,4,5,6}; couts\u0026lt;\u0026lt; url[1] \u0026lt;\u0026lt; endl; return 0; }  2.Only have one \u0026lsquo;return\u0026rsquo; # Error constexpr int display(int x) { int ret = 1 + 2 + x; return ret; } # True constexpr int display(int x) { return 1 + 2 + x; }  3.","lvl0":"Constexpr","lvl1":null,"lvl2":"摘要","objectID":"24f836c90e47fb29eae728ecce55c6ed","tags":["CPP","const","function"],"url":"https://6923403.github.io/post/constexpr/"},{"content":"Start gdb or gdb -q # exit ctrl + d or quit  Use g++ -g main.cpp -o main gdb main -q or gdb -q file main Debug runing program\nps ux | grep showpng gdb showpng 28334 -q  CoreDump ** Check if off **\nulimit -c 0 # is off # tmp use ulimit -c unlimited ulimit -c unlimited # turn open permanent use\nvim /etc/security/limits.conf # add line * soft core unlimited # and echo \u0026quot;core.","lvl0":"GDB tutorial","lvl1":null,"lvl2":"摘要","objectID":"f089e2c89bb7388837f85769b40baa03","tags":["GDB","Linux","CPP"],"url":"https://6923403.github.io/post/use_gdb/"},{"content":"./start.sh 1 2 3 4 num: $# = 4 PID: $$ = 24133 sname: $0 = start.sh first: $1 = 1 secont: $2 = 2 $@ = 1234 #value list $* = 1234 #value   $* 1 2 3 4  ","lvl0":"Shell_command($!, $@...)","lvl1":null,"lvl2":"摘要","objectID":"9e8542dee3e5e6d5ab32ecee45d1beb7","tags":["Linux","shell"],"url":"https://6923403.github.io/post/shell_commans/"},{"content":"updat\u0026hellip;\n1. install xorg pacman -S xorg-server xorg-xinit 2. install zsh, feh, i3gapsr, compton, oh-my-zsh pacman -S zsh xfce4-terminal feh compton i3-gaps nautilus i3lock sh -c \u0026quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026quot;  install ttf pacman -S ttf-liberation pacman -S adobe-source-han-sans-cn-fonts pacman -S adobe-source-han-sans-tw-fonts pacman -S adobe-source-han-sans-jp-fonts  add user useradd -m -g users -s /bin/zsh xxxx #添加xxxx用户，用户名你自定义 passwd xxxx #为xxxx用户设置密码 vim /etc/sudoers #编辑配置文件 在root ALL = (ALL) ALL下添加xxxx ALL = (ALL) ALL;输入:wq!强制保存退出vim  startx exit login new user touch .","lvl0":"Arch Beautify desktop","lvl1":null,"lvl2":"摘要","objectID":"78b825ed3e594c3d624fa1e159eae974","tags":["Arch","Linux","i3wm"],"url":"https://6923403.github.io/post/arch_desktop/"},{"content":"0. Ready work Test environment: Vmware15.5.6pro arch-2020-07.iso You should installed Vmware and download Archlinux iso .\nChange your firmwaretype to UEFI (The way many tutorials did not say)  1. Start ls /sys/firmware/efi/efivars The command detect UEFI files and if your dir not include files your firmwaretype is BIOS .\nThen, ping google.com, detect interent connection\n Archwiki: Note: The installation image has systemd-networkd.service, systemd-resolved.service and iwd.service enabled by default. That will not be the case for the installed system.","lvl0":"Vmware install Archlinux ","lvl1":null,"lvl2":"摘要","objectID":"48da6375cbeadf1f57f99f6d9403d318","tags":["Linux","Arch"],"url":"https://6923403.github.io/post/arch_install/"},{"content":"0. Hugo \u0026amp; Markdown Hugo \u0026amp;\u0026amp; MarkDown\n 1. MarkDown template --- title: \u0026quot;{{ replace .Name \u0026quot;-\u0026quot; \u0026quot; \u0026quot; | title }}\u0026quot; date: {{ .Date }} lastmod: {{ .Date }} draft: false tags: [ ] categories: [ ] comment: true ---  2. Hugo command hugo #build html havn't draft=true hugo -D #build html and dragt=true hugo server #Start hugo server  3. Other Reference","lvl0":"Hugo \u0026 Markdown","lvl1":null,"lvl2":"摘要","objectID":"9e98dcdb5f8e120827a32ea4149b5223","tags":["hugo","markdown"],"url":"https://6923403.github.io/post/hugomarkdown/"},{"content":"0.Ready work Disable BIOS secure boot，choose disable .\n 1. Uninstall old Nvidia drivers sudo apt-get remove --purge nvidia*  2. Add rules vim /etc/modprobe.d/blacklist.conf\n1. blacklist nouveau 2. options nouveau modeset=0  3. Verification After reboot, use the following command no return is successful\nsudo update-initramfs -u lsmod | grep nouveau  4. Choose Navidia drivers version  1.Use command: ubuntu-drivers devices 2.Nvidia Official website  Choose stable version and install","lvl0":"Ubuntu20 Install Nvidia drivers","lvl1":null,"lvl2":"摘要","objectID":"a185fa534071064a3174a40c5b823ac8","tags":["linux","drivers","Ubuntu","Nvidia"],"url":"https://6923403.github.io/post/install_nvidia/"},{"content":"void fun(char * fmt, \u0026hellip;); int vsprintf(char *str, const char *format, va_list arg);\n  Test programming #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; /* * Re: https://github.com/antirez/kilo/kilo.c * Re: https://www.runoob.com/cprogramming/c-function-vsprintf.html */ char buffer[80]; int editorSetstatus(const char * fmt, ...) { va_list ap; va_start(ap, fmt); int ret; ret = vsnprintf(buffer, sizeof(buffer - 1), fmt, ap); va_end(ap); return (ret); } int main(int argc, char **argv) { int len = 20; editorSetstatus(\u0026quot;%d\u0026quot;, len); printf(\u0026quot;%s \\n\u0026quot;, buffer); return 0; }  gcc -Wall -g fun.","lvl0":"Variable function(fun(char *, ...)) and vsnprintf()","lvl1":null,"lvl2":"摘要","objectID":"ff844f7d0d70477e742c034fb437a5f7","tags":["CPP","GCC"],"url":"https://6923403.github.io/post/variable_function/"},{"content":"Boost C++ is Cpp programming language that provides support for tasks and structures\n Download Source https://dl.bintray.com/boostorg/release/1.73.0/source/boost_1_73_0.tar.gz tar zxvf boost(解压)  Set use GCC cd boost ./bootstrap.sh --with-libraries=all --with-toolset=gcc  Compile \u0026amp; Install boost ./b2 toolset=gcc ./b2 install --prefix=/usr  Test programming #include \u0026lt;boost/thread/thread.hpp\u0026gt; //boost thread #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; volatile bool isRuning = true; void func1() { static int cnt1 = 0; while(isRuning) { cout \u0026lt;\u0026lt; \u0026quot;func1:\u0026quot; \u0026lt;\u0026lt; cnt1++ \u0026lt;\u0026lt; endl; sleep(1); } } void func2() { static int cnt2 = 0; while(isRuning) { cout \u0026lt;\u0026lt; \u0026quot;\\tfunc2:\u0026quot; \u0026lt;\u0026lt; cnt2++ \u0026lt;\u0026lt; endl; sleep(2); } } int main() { boost::thread thread1(\u0026amp;func1); boost::thread thread2(\u0026amp;func2); system(\u0026quot;read\u0026quot;); isRuning = false; thread2.","lvl0":"Linux install Boost c++","lvl1":null,"lvl2":"摘要","objectID":"76fc4ecaf0a8ad44f2bb5d8f8544f5f8","tags":["Boost","Linux","CPP"],"url":"https://6923403.github.io/post/linux_install_boost/"},{"content":"Start Download FFmpeg  Install tool 1. install yasm\nsudo apt-get install yasm  if not installed yasm, os will output \u0026ldquo;nasm/yasm not found or too old. Use \u0026ndash;disable-x86asm for a crippled build.\u0026rdquo;\n 2. install SDL2\nSDL2-2.0.12(stable)\ntar -xvf SDL2-2.0.12.tar.gz cd SDL2-2.0.12 ./configure sudo make -j4 sudo make install  Install FFmpeg 1. git clone https://git.ffmpeg.org/ffmpeg.git ffmpeg\ncd ffmpeg/ ./configure sudo make -j4 sudo make install  3. Check ffmpeg -version ffplay -version ","lvl0":"Ubuntu20 install FFmpeg","lvl1":null,"lvl2":"摘要","objectID":"93cc3d2515e52b591c79cc31f823b458","tags":["linux","FFmpeg","Ubuntu"],"url":"https://6923403.github.io/post/ffmpeg_install/"}]